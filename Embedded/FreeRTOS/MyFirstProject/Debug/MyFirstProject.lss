
MyFirstProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003c  00800200  00001cf6  00001d8a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001cf6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000090  0080023c  0080023c  00001dc6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001dc6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001df8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000560  00000000  00000000  00001e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006e01  00000000  00000000  00002398  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001cf5  00000000  00000000  00009199  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000037e0  00000000  00000000  0000ae8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f2c  00000000  00000000  0000e670  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002130  00000000  00000000  0000f59c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e9b  00000000  00000000  000116cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005e8  00000000  00000000  00017567  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c1       	rjmp	.+868    	; 0x366 <__ctors_end>
       2:	00 00       	nop
       4:	d1 c1       	rjmp	.+930    	; 0x3a8 <__bad_interrupt>
       6:	00 00       	nop
       8:	cf c1       	rjmp	.+926    	; 0x3a8 <__bad_interrupt>
       a:	00 00       	nop
       c:	cd c1       	rjmp	.+922    	; 0x3a8 <__bad_interrupt>
       e:	00 00       	nop
      10:	cb c1       	rjmp	.+918    	; 0x3a8 <__bad_interrupt>
      12:	00 00       	nop
      14:	c9 c1       	rjmp	.+914    	; 0x3a8 <__bad_interrupt>
      16:	00 00       	nop
      18:	c7 c1       	rjmp	.+910    	; 0x3a8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c5 c1       	rjmp	.+906    	; 0x3a8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c3 c1       	rjmp	.+902    	; 0x3a8 <__bad_interrupt>
      22:	00 00       	nop
      24:	c1 c1       	rjmp	.+898    	; 0x3a8 <__bad_interrupt>
      26:	00 00       	nop
      28:	bf c1       	rjmp	.+894    	; 0x3a8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bd c1       	rjmp	.+890    	; 0x3a8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ec c3       	rjmp	.+2008   	; 0x80a <__vector_12>
      32:	00 00       	nop
      34:	b9 c1       	rjmp	.+882    	; 0x3a8 <__bad_interrupt>
      36:	00 00       	nop
      38:	b7 c1       	rjmp	.+878    	; 0x3a8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b5 c1       	rjmp	.+874    	; 0x3a8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b3 c1       	rjmp	.+870    	; 0x3a8 <__bad_interrupt>
      42:	00 00       	nop
      44:	b1 c1       	rjmp	.+866    	; 0x3a8 <__bad_interrupt>
      46:	00 00       	nop
      48:	af c1       	rjmp	.+862    	; 0x3a8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ad c1       	rjmp	.+858    	; 0x3a8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	ab c1       	rjmp	.+854    	; 0x3a8 <__bad_interrupt>
      52:	00 00       	nop
      54:	a9 c1       	rjmp	.+850    	; 0x3a8 <__bad_interrupt>
      56:	00 00       	nop
      58:	a7 c1       	rjmp	.+846    	; 0x3a8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a5 c1       	rjmp	.+842    	; 0x3a8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a3 c1       	rjmp	.+838    	; 0x3a8 <__bad_interrupt>
      62:	00 00       	nop
      64:	a1 c1       	rjmp	.+834    	; 0x3a8 <__bad_interrupt>
      66:	00 00       	nop
      68:	9f c1       	rjmp	.+830    	; 0x3a8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	9d c1       	rjmp	.+826    	; 0x3a8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9b c1       	rjmp	.+822    	; 0x3a8 <__bad_interrupt>
      72:	00 00       	nop
      74:	99 c1       	rjmp	.+818    	; 0x3a8 <__bad_interrupt>
      76:	00 00       	nop
      78:	97 c1       	rjmp	.+814    	; 0x3a8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	95 c1       	rjmp	.+810    	; 0x3a8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	93 c1       	rjmp	.+806    	; 0x3a8 <__bad_interrupt>
      82:	00 00       	nop
      84:	91 c1       	rjmp	.+802    	; 0x3a8 <__bad_interrupt>
      86:	00 00       	nop
      88:	8f c1       	rjmp	.+798    	; 0x3a8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8d c1       	rjmp	.+794    	; 0x3a8 <__bad_interrupt>
      8e:	00 00       	nop
      90:	8b c1       	rjmp	.+790    	; 0x3a8 <__bad_interrupt>
      92:	00 00       	nop
      94:	89 c1       	rjmp	.+786    	; 0x3a8 <__bad_interrupt>
      96:	00 00       	nop
      98:	87 c1       	rjmp	.+782    	; 0x3a8 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	85 c1       	rjmp	.+778    	; 0x3a8 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	83 c1       	rjmp	.+774    	; 0x3a8 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	81 c1       	rjmp	.+770    	; 0x3a8 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7f c1       	rjmp	.+766    	; 0x3a8 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7d c1       	rjmp	.+762    	; 0x3a8 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7b c1       	rjmp	.+758    	; 0x3a8 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	79 c1       	rjmp	.+754    	; 0x3a8 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	77 c1       	rjmp	.+750    	; 0x3a8 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	75 c1       	rjmp	.+746    	; 0x3a8 <__bad_interrupt>
      be:	00 00       	nop
      c0:	73 c1       	rjmp	.+742    	; 0x3a8 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	71 c1       	rjmp	.+738    	; 0x3a8 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6f c1       	rjmp	.+734    	; 0x3a8 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6d c1       	rjmp	.+730    	; 0x3a8 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6b c1       	rjmp	.+726    	; 0x3a8 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	69 c1       	rjmp	.+722    	; 0x3a8 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	67 c1       	rjmp	.+718    	; 0x3a8 <__bad_interrupt>
      da:	00 00       	nop
      dc:	65 c1       	rjmp	.+714    	; 0x3a8 <__bad_interrupt>
      de:	00 00       	nop
      e0:	63 c1       	rjmp	.+710    	; 0x3a8 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	43 01       	movw	r8, r6
      e6:	43 01       	movw	r8, r6
      e8:	43 01       	movw	r8, r6
      ea:	72 01       	movw	r14, r4
      ec:	7a 01       	movw	r14, r20
      ee:	89 01       	movw	r16, r18
      f0:	43 01       	movw	r8, r6
      f2:	43 01       	movw	r8, r6
      f4:	72 01       	movw	r14, r4
      f6:	7a 01       	movw	r14, r20

000000f8 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
      f8:	04 e5       	ldi	r16, 0x54	; 84
      fa:	12 e0       	ldi	r17, 0x02	; 2
      fc:	0f 2e       	mov	r0, r31
      fe:	fc e7       	ldi	r31, 0x7C	; 124
     100:	ef 2e       	mov	r14, r31
     102:	f2 e0       	ldi	r31, 0x02	; 2
     104:	ff 2e       	mov	r15, r31
     106:	f0 2d       	mov	r31, r0
     108:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <uxDeletedTasksWaitingCleanUp>
     10c:	88 23       	and	r24, r24
     10e:	11 f1       	breq	.+68     	; 0x154 <prvIdleTask+0x5c>
     110:	0f b6       	in	r0, 0x3f	; 63
     112:	f8 94       	cli
     114:	0f 92       	push	r0
     116:	d8 01       	movw	r26, r16
     118:	15 96       	adiw	r26, 0x05	; 5
     11a:	ed 91       	ld	r30, X+
     11c:	fc 91       	ld	r31, X
     11e:	16 97       	sbiw	r26, 0x06	; 6
     120:	c6 81       	ldd	r28, Z+6	; 0x06
     122:	d7 81       	ldd	r29, Z+7	; 0x07
     124:	ce 01       	movw	r24, r28
     126:	02 96       	adiw	r24, 0x02	; 2
     128:	d8 d1       	rcall	.+944    	; 0x4da <uxListRemove>
     12a:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
     12e:	81 50       	subi	r24, 0x01	; 1
     130:	80 93 49 02 	sts	0x0249, r24	; 0x800249 <uxCurrentNumberOfTasks>
     134:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <uxDeletedTasksWaitingCleanUp>
     138:	81 50       	subi	r24, 0x01	; 1
     13a:	80 93 53 02 	sts	0x0253, r24	; 0x800253 <uxDeletedTasksWaitingCleanUp>
     13e:	0f 90       	pop	r0
     140:	0f be       	out	0x3f, r0	; 63
     142:	8f 89       	ldd	r24, Y+23	; 0x17
     144:	98 8d       	ldd	r25, Y+24	; 0x18
     146:	58 d1       	rcall	.+688    	; 0x3f8 <vPortFree>
     148:	ce 01       	movw	r24, r28
     14a:	56 d1       	rcall	.+684    	; 0x3f8 <vPortFree>
     14c:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <uxDeletedTasksWaitingCleanUp>
     150:	81 11       	cpse	r24, r1
     152:	de cf       	rjmp	.-68     	; 0x110 <prvIdleTask+0x18>
     154:	f7 01       	movw	r30, r14
     156:	80 81       	ld	r24, Z
     158:	82 30       	cpi	r24, 0x02	; 2
     15a:	08 f0       	brcs	.+2      	; 0x15e <prvIdleTask+0x66>
     15c:	93 d2       	rcall	.+1318   	; 0x684 <vPortYield>
     15e:	0e 94 93 0c 	call	0x1926	; 0x1926 <vApplicationIdleHook>
     162:	d2 cf       	rjmp	.-92     	; 0x108 <prvIdleTask+0x10>

00000164 <prvTimerTask>:
     164:	cf 93       	push	r28
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
     166:	df 93       	push	r29
     168:	00 d0       	rcall	.+0      	; 0x16a <prvTimerTask+0x6>
     16a:	00 d0       	rcall	.+0      	; 0x16c <prvTimerTask+0x8>
     16c:	cd b7       	in	r28, 0x3d	; 61
     16e:	de b7       	in	r29, 0x3e	; 62
     170:	ce 01       	movw	r24, r28
     172:	01 96       	adiw	r24, 0x01	; 1
     174:	4c 01       	movw	r8, r24
     176:	44 24       	eor	r4, r4
     178:	43 94       	inc	r4
     17a:	e1 2c       	mov	r14, r1
     17c:	f1 2c       	mov	r15, r1
     17e:	51 2c       	mov	r5, r1
     180:	c8 2e       	mov	r12, r24
     182:	d9 2c       	mov	r13, r9
     184:	e0 91 aa 02 	lds	r30, 0x02AA	; 0x8002aa <pxCurrentTimerList>
     188:	f0 91 ab 02 	lds	r31, 0x02AB	; 0x8002ab <pxCurrentTimerList+0x1>
     18c:	80 81       	ld	r24, Z
     18e:	88 23       	and	r24, r24
     190:	09 f4       	brne	.+2      	; 0x194 <prvTimerTask+0x30>
     192:	d6 c0       	rjmp	.+428    	; 0x340 <prvTimerTask+0x1dc>
     194:	05 80       	ldd	r0, Z+5	; 0x05
     196:	f6 81       	ldd	r31, Z+6	; 0x06
     198:	e0 2d       	mov	r30, r0
     19a:	a0 80       	ld	r10, Z
     19c:	b1 80       	ldd	r11, Z+1	; 0x01
     19e:	aa d7       	rcall	.+3924   	; 0x10f4 <vTaskSuspendAll>
     1a0:	c4 01       	movw	r24, r8
     1a2:	0e 94 25 0c 	call	0x184a	; 0x184a <prvSampleTimeNow>
     1a6:	8c 01       	movw	r16, r24
     1a8:	89 81       	ldd	r24, Y+1	; 0x01
     1aa:	81 11       	cpse	r24, r1
     1ac:	48 c0       	rjmp	.+144    	; 0x23e <prvTimerTask+0xda>
     1ae:	0a 15       	cp	r16, r10
     1b0:	1b 05       	cpc	r17, r11
     1b2:	b0 f1       	brcs	.+108    	; 0x220 <prvTimerTask+0xbc>
     1b4:	0e 94 41 09 	call	0x1282	; 0x1282 <xTaskResumeAll>
     1b8:	e0 91 aa 02 	lds	r30, 0x02AA	; 0x8002aa <pxCurrentTimerList>
     1bc:	f0 91 ab 02 	lds	r31, 0x02AB	; 0x8002ab <pxCurrentTimerList+0x1>
     1c0:	05 80       	ldd	r0, Z+5	; 0x05
     1c2:	f6 81       	ldd	r31, Z+6	; 0x06
     1c4:	e0 2d       	mov	r30, r0
     1c6:	66 80       	ldd	r6, Z+6	; 0x06
     1c8:	77 80       	ldd	r7, Z+7	; 0x07
     1ca:	c3 01       	movw	r24, r6
     1cc:	02 96       	adiw	r24, 0x02	; 2
     1ce:	85 d1       	rcall	.+778    	; 0x4da <uxListRemove>
     1d0:	d3 01       	movw	r26, r6
     1d2:	53 96       	adiw	r26, 0x13	; 19
     1d4:	8c 91       	ld	r24, X
     1d6:	53 97       	sbiw	r26, 0x13	; 19
     1d8:	82 ff       	sbrs	r24, 2
     1da:	17 c0       	rjmp	.+46     	; 0x20a <prvTimerTask+0xa6>
     1dc:	1c 96       	adiw	r26, 0x0c	; 12
     1de:	6d 91       	ld	r22, X+
     1e0:	7c 91       	ld	r23, X
     1e2:	1d 97       	sbiw	r26, 0x0d	; 13
     1e4:	6a 0d       	add	r22, r10
     1e6:	7b 1d       	adc	r23, r11
     1e8:	95 01       	movw	r18, r10
     1ea:	a8 01       	movw	r20, r16
     1ec:	c3 01       	movw	r24, r6
     1ee:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <prvInsertTimerInActiveList>
     1f2:	88 23       	and	r24, r24
     1f4:	69 f0       	breq	.+26     	; 0x210 <prvTimerTask+0xac>
     1f6:	0e 2d       	mov	r16, r14
     1f8:	1f 2d       	mov	r17, r15
     1fa:	2e 2d       	mov	r18, r14
     1fc:	3f 2d       	mov	r19, r15
     1fe:	a5 01       	movw	r20, r10
     200:	65 2d       	mov	r22, r5
     202:	c3 01       	movw	r24, r6
     204:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTimerGenericCommand>
     208:	03 c0       	rjmp	.+6      	; 0x210 <prvTimerTask+0xac>
     20a:	8e 7f       	andi	r24, 0xFE	; 254
     20c:	f3 01       	movw	r30, r6
     20e:	83 8b       	std	Z+19, r24	; 0x13
     210:	d3 01       	movw	r26, r6
     212:	50 96       	adiw	r26, 0x10	; 16
     214:	ed 91       	ld	r30, X+
     216:	fc 91       	ld	r31, X
     218:	51 97       	sbiw	r26, 0x11	; 17
     21a:	c3 01       	movw	r24, r6
     21c:	19 95       	eicall
     21e:	84 c0       	rjmp	.+264    	; 0x328 <prvTimerTask+0x1c4>
     220:	45 2d       	mov	r20, r5
     222:	b5 01       	movw	r22, r10
     224:	60 1b       	sub	r22, r16
     226:	71 0b       	sbc	r23, r17
     228:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <xTimerQueue>
     22c:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <xTimerQueue+0x1>
     230:	95 d5       	rcall	.+2858   	; 0xd5c <vQueueWaitForMessageRestricted>
     232:	0e 94 41 09 	call	0x1282	; 0x1282 <xTaskResumeAll>
     236:	81 11       	cpse	r24, r1
     238:	77 c0       	rjmp	.+238    	; 0x328 <prvTimerTask+0x1c4>
     23a:	24 d2       	rcall	.+1096   	; 0x684 <vPortYield>
     23c:	75 c0       	rjmp	.+234    	; 0x328 <prvTimerTask+0x1c4>
     23e:	0e 94 41 09 	call	0x1282	; 0x1282 <xTaskResumeAll>
     242:	72 c0       	rjmp	.+228    	; 0x328 <prvTimerTask+0x1c4>
     244:	89 81       	ldd	r24, Y+1	; 0x01
     246:	88 23       	and	r24, r24
     248:	0c f4       	brge	.+2      	; 0x24c <prvTimerTask+0xe8>
     24a:	6e c0       	rjmp	.+220    	; 0x328 <prvTimerTask+0x1c4>
     24c:	ac 80       	ldd	r10, Y+4	; 0x04
     24e:	bd 80       	ldd	r11, Y+5	; 0x05
     250:	f5 01       	movw	r30, r10
     252:	82 85       	ldd	r24, Z+10	; 0x0a
     254:	93 85       	ldd	r25, Z+11	; 0x0b
     256:	89 2b       	or	r24, r25
     258:	19 f0       	breq	.+6      	; 0x260 <prvTimerTask+0xfc>
     25a:	c5 01       	movw	r24, r10
     25c:	02 96       	adiw	r24, 0x02	; 2
     25e:	3d d1       	rcall	.+634    	; 0x4da <uxListRemove>
     260:	ce 01       	movw	r24, r28
     262:	06 96       	adiw	r24, 0x06	; 6
     264:	0e 94 25 0c 	call	0x184a	; 0x184a <prvSampleTimeNow>
     268:	ac 01       	movw	r20, r24
     26a:	e9 81       	ldd	r30, Y+1	; 0x01
     26c:	0e 2e       	mov	r0, r30
     26e:	00 0c       	add	r0, r0
     270:	ff 0b       	sbc	r31, r31
     272:	ea 30       	cpi	r30, 0x0A	; 10
     274:	f1 05       	cpc	r31, r1
     276:	08 f0       	brcs	.+2      	; 0x27a <prvTimerTask+0x116>
     278:	57 c0       	rjmp	.+174    	; 0x328 <prvTimerTask+0x1c4>
     27a:	88 27       	eor	r24, r24
     27c:	ee 58       	subi	r30, 0x8E	; 142
     27e:	ff 4f       	sbci	r31, 0xFF	; 255
     280:	8f 4f       	sbci	r24, 0xFF	; 255
     282:	0c 94 10 0d 	jmp	0x1a20	; 0x1a20 <__tablejump2__>
     286:	d5 01       	movw	r26, r10
     288:	53 96       	adiw	r26, 0x13	; 19
     28a:	8c 91       	ld	r24, X
     28c:	53 97       	sbiw	r26, 0x13	; 19
     28e:	81 60       	ori	r24, 0x01	; 1
     290:	53 96       	adiw	r26, 0x13	; 19
     292:	8c 93       	st	X, r24
     294:	53 97       	sbiw	r26, 0x13	; 19
     296:	2a 81       	ldd	r18, Y+2	; 0x02
     298:	3b 81       	ldd	r19, Y+3	; 0x03
     29a:	1c 96       	adiw	r26, 0x0c	; 12
     29c:	6d 91       	ld	r22, X+
     29e:	7c 91       	ld	r23, X
     2a0:	1d 97       	sbiw	r26, 0x0d	; 13
     2a2:	62 0f       	add	r22, r18
     2a4:	73 1f       	adc	r23, r19
     2a6:	c5 01       	movw	r24, r10
     2a8:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <prvInsertTimerInActiveList>
     2ac:	88 23       	and	r24, r24
     2ae:	e1 f1       	breq	.+120    	; 0x328 <prvTimerTask+0x1c4>
     2b0:	d5 01       	movw	r26, r10
     2b2:	50 96       	adiw	r26, 0x10	; 16
     2b4:	ed 91       	ld	r30, X+
     2b6:	fc 91       	ld	r31, X
     2b8:	51 97       	sbiw	r26, 0x11	; 17
     2ba:	c5 01       	movw	r24, r10
     2bc:	19 95       	eicall
     2be:	f5 01       	movw	r30, r10
     2c0:	83 89       	ldd	r24, Z+19	; 0x13
     2c2:	82 ff       	sbrs	r24, 2
     2c4:	31 c0       	rjmp	.+98     	; 0x328 <prvTimerTask+0x1c4>
     2c6:	4a 81       	ldd	r20, Y+2	; 0x02
     2c8:	5b 81       	ldd	r21, Y+3	; 0x03
     2ca:	84 85       	ldd	r24, Z+12	; 0x0c
     2cc:	95 85       	ldd	r25, Z+13	; 0x0d
     2ce:	48 0f       	add	r20, r24
     2d0:	59 1f       	adc	r21, r25
     2d2:	0e 2d       	mov	r16, r14
     2d4:	1f 2d       	mov	r17, r15
     2d6:	2e 2d       	mov	r18, r14
     2d8:	3f 2d       	mov	r19, r15
     2da:	65 2d       	mov	r22, r5
     2dc:	c5 01       	movw	r24, r10
     2de:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <xTimerGenericCommand>
     2e2:	22 c0       	rjmp	.+68     	; 0x328 <prvTimerTask+0x1c4>
     2e4:	d5 01       	movw	r26, r10
     2e6:	53 96       	adiw	r26, 0x13	; 19
     2e8:	8c 91       	ld	r24, X
     2ea:	53 97       	sbiw	r26, 0x13	; 19
     2ec:	8e 7f       	andi	r24, 0xFE	; 254
     2ee:	53 96       	adiw	r26, 0x13	; 19
     2f0:	8c 93       	st	X, r24
     2f2:	1a c0       	rjmp	.+52     	; 0x328 <prvTimerTask+0x1c4>
     2f4:	f5 01       	movw	r30, r10
     2f6:	83 89       	ldd	r24, Z+19	; 0x13
     2f8:	81 60       	ori	r24, 0x01	; 1
     2fa:	83 8b       	std	Z+19, r24	; 0x13
     2fc:	6a 81       	ldd	r22, Y+2	; 0x02
     2fe:	7b 81       	ldd	r23, Y+3	; 0x03
     300:	75 87       	std	Z+13, r23	; 0x0d
     302:	64 87       	std	Z+12, r22	; 0x0c
     304:	64 0f       	add	r22, r20
     306:	75 1f       	adc	r23, r21
     308:	9a 01       	movw	r18, r20
     30a:	c5 01       	movw	r24, r10
     30c:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <prvInsertTimerInActiveList>
     310:	0b c0       	rjmp	.+22     	; 0x328 <prvTimerTask+0x1c4>
     312:	d5 01       	movw	r26, r10
     314:	53 96       	adiw	r26, 0x13	; 19
     316:	8c 91       	ld	r24, X
     318:	81 fd       	sbrc	r24, 1
     31a:	03 c0       	rjmp	.+6      	; 0x322 <prvTimerTask+0x1be>
     31c:	c5 01       	movw	r24, r10
     31e:	6c d0       	rcall	.+216    	; 0x3f8 <vPortFree>
     320:	03 c0       	rjmp	.+6      	; 0x328 <prvTimerTask+0x1c4>
     322:	8e 7f       	andi	r24, 0xFE	; 254
     324:	f5 01       	movw	r30, r10
     326:	83 8b       	std	Z+19, r24	; 0x13
     328:	4e 2d       	mov	r20, r14
     32a:	5f 2d       	mov	r21, r15
     32c:	6c 2d       	mov	r22, r12
     32e:	7d 2d       	mov	r23, r13
     330:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <xTimerQueue>
     334:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <xTimerQueue+0x1>
     338:	88 d4       	rcall	.+2320   	; 0xc4a <xQueueReceive>
     33a:	81 11       	cpse	r24, r1
     33c:	83 cf       	rjmp	.-250    	; 0x244 <prvTimerTask+0xe0>
     33e:	22 cf       	rjmp	.-444    	; 0x184 <prvTimerTask+0x20>
     340:	d9 d6       	rcall	.+3506   	; 0x10f4 <vTaskSuspendAll>
     342:	c4 01       	movw	r24, r8
     344:	0e 94 25 0c 	call	0x184a	; 0x184a <prvSampleTimeNow>
     348:	8c 01       	movw	r16, r24
     34a:	89 81       	ldd	r24, Y+1	; 0x01
     34c:	81 11       	cpse	r24, r1
     34e:	77 cf       	rjmp	.-274    	; 0x23e <prvTimerTask+0xda>
     350:	e0 91 a8 02 	lds	r30, 0x02A8	; 0x8002a8 <pxOverflowTimerList>
     354:	f0 91 a9 02 	lds	r31, 0x02A9	; 0x8002a9 <pxOverflowTimerList+0x1>
     358:	80 81       	ld	r24, Z
     35a:	44 2d       	mov	r20, r4
     35c:	81 11       	cpse	r24, r1
     35e:	45 2d       	mov	r20, r5
     360:	ae 2c       	mov	r10, r14
     362:	bf 2c       	mov	r11, r15
     364:	5e cf       	rjmp	.-324    	; 0x222 <prvTimerTask+0xbe>

00000366 <__ctors_end>:
     366:	11 24       	eor	r1, r1
     368:	1f be       	out	0x3f, r1	; 63
     36a:	cf ef       	ldi	r28, 0xFF	; 255
     36c:	d1 e2       	ldi	r29, 0x21	; 33
     36e:	de bf       	out	0x3e, r29	; 62
     370:	cd bf       	out	0x3d, r28	; 61
     372:	00 e0       	ldi	r16, 0x00	; 0
     374:	0c bf       	out	0x3c, r16	; 60

00000376 <__do_copy_data>:
     376:	12 e0       	ldi	r17, 0x02	; 2
     378:	a0 e0       	ldi	r26, 0x00	; 0
     37a:	b2 e0       	ldi	r27, 0x02	; 2
     37c:	e6 ef       	ldi	r30, 0xF6	; 246
     37e:	fc e1       	ldi	r31, 0x1C	; 28
     380:	00 e0       	ldi	r16, 0x00	; 0
     382:	0b bf       	out	0x3b, r16	; 59
     384:	02 c0       	rjmp	.+4      	; 0x38a <__do_copy_data+0x14>
     386:	07 90       	elpm	r0, Z+
     388:	0d 92       	st	X+, r0
     38a:	ac 33       	cpi	r26, 0x3C	; 60
     38c:	b1 07       	cpc	r27, r17
     38e:	d9 f7       	brne	.-10     	; 0x386 <__do_copy_data+0x10>

00000390 <__do_clear_bss>:
     390:	22 e0       	ldi	r18, 0x02	; 2
     392:	ac e3       	ldi	r26, 0x3C	; 60
     394:	b2 e0       	ldi	r27, 0x02	; 2
     396:	01 c0       	rjmp	.+2      	; 0x39a <.do_clear_bss_start>

00000398 <.do_clear_bss_loop>:
     398:	1d 92       	st	X+, r1

0000039a <.do_clear_bss_start>:
     39a:	ac 3c       	cpi	r26, 0xCC	; 204
     39c:	b2 07       	cpc	r27, r18
     39e:	e1 f7       	brne	.-8      	; 0x398 <.do_clear_bss_loop>
     3a0:	0e 94 ae 0c 	call	0x195c	; 0x195c <main>
     3a4:	0c 94 79 0e 	jmp	0x1cf2	; 0x1cf2 <_exit>

000003a8 <__bad_interrupt>:
     3a8:	2b ce       	rjmp	.-938    	; 0x0 <__vectors>

000003aa <trace_init>:
	 #if (configUSE_TRACE_FACILITY == 1)
	 #ifdef HAL_DEFS_H_

	 #else
		// Used on VIA MEGA Shield rev. 2.0.0
		DDRK |= _BV(DDK0) | _BV(DDK1) | _BV(DDK2) | _BV(DDK3);
     3aa:	e7 e0       	ldi	r30, 0x07	; 7
     3ac:	f1 e0       	ldi	r31, 0x01	; 1
     3ae:	80 81       	ld	r24, Z
     3b0:	8f 60       	ori	r24, 0x0F	; 15
     3b2:	80 83       	st	Z, r24
     3b4:	08 95       	ret

000003b6 <task_switch_in>:
	void task_switch_in(uint8_t task_no) {
		 #ifdef HAL_DEFS_H_

		 #else
		 // Used on VIA MEGA Shield rev. 2.0.0
		 PORTK &= 0b11110000;
     3b6:	e8 e0       	ldi	r30, 0x08	; 8
     3b8:	f1 e0       	ldi	r31, 0x01	; 1
     3ba:	90 81       	ld	r25, Z
     3bc:	90 7f       	andi	r25, 0xF0	; 240
     3be:	90 83       	st	Z, r25
		 PORTK |= (task_no & 0b00001111);
     3c0:	90 81       	ld	r25, Z
     3c2:	8f 70       	andi	r24, 0x0F	; 15
     3c4:	98 2b       	or	r25, r24
     3c6:	90 83       	st	Z, r25
     3c8:	08 95       	ret

000003ca <task_switch_out>:
	void task_switch_out(uint8_t task_no) {
		#ifdef HAL_DEFS_H_

		#else
		// Used on VIA MEGA Shield rev. 2.0.0
		PORTK &= 0b11110000;
     3ca:	e8 e0       	ldi	r30, 0x08	; 8
     3cc:	f1 e0       	ldi	r31, 0x01	; 1
     3ce:	80 81       	ld	r24, Z
     3d0:	80 7f       	andi	r24, 0xF0	; 240
     3d2:	80 83       	st	Z, r24
     3d4:	08 95       	ret

000003d6 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3d6:	cf 93       	push	r28
     3d8:	df 93       	push	r29
     3da:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
     3dc:	8b d6       	rcall	.+3350   	; 0x10f4 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
     3de:	ce 01       	movw	r24, r28
     3e0:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <malloc>
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     3e4:	ec 01       	movw	r28, r24
     3e6:	4d d7       	rcall	.+3738   	; 0x1282 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
     3e8:	20 97       	sbiw	r28, 0x00	; 0
     3ea:	11 f4       	brne	.+4      	; 0x3f0 <pvPortMalloc+0x1a>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
     3ec:	0e 94 94 0c 	call	0x1928	; 0x1928 <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
     3f0:	ce 01       	movw	r24, r28
     3f2:	df 91       	pop	r29
     3f4:	cf 91       	pop	r28
     3f6:	08 95       	ret

000003f8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     3f8:	cf 93       	push	r28
     3fa:	df 93       	push	r29
    if( pv )
     3fc:	00 97       	sbiw	r24, 0x00	; 0
     3fe:	31 f0       	breq	.+12     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     400:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
     402:	78 d6       	rcall	.+3312   	; 0x10f4 <vTaskSuspendAll>
        {
            free( pv );
     404:	ce 01       	movw	r24, r28
     406:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
     40a:	3b d7       	rcall	.+3702   	; 0x1282 <xTaskResumeAll>
    }
}
     40c:	df 91       	pop	r29
     40e:	cf 91       	pop	r28
     410:	08 95       	ret

00000412 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     412:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     414:	03 96       	adiw	r24, 0x03	; 3
     416:	92 83       	std	Z+2, r25	; 0x02
     418:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     41a:	2f ef       	ldi	r18, 0xFF	; 255
     41c:	3f ef       	ldi	r19, 0xFF	; 255
     41e:	34 83       	std	Z+4, r19	; 0x04
     420:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     422:	96 83       	std	Z+6, r25	; 0x06
     424:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     426:	90 87       	std	Z+8, r25	; 0x08
     428:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     42a:	10 82       	st	Z, r1
     42c:	08 95       	ret

0000042e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     42e:	fc 01       	movw	r30, r24
     430:	11 86       	std	Z+9, r1	; 0x09
     432:	10 86       	std	Z+8, r1	; 0x08
     434:	08 95       	ret

00000436 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	9c 01       	movw	r18, r24
     43c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     43e:	dc 01       	movw	r26, r24
     440:	11 96       	adiw	r26, 0x01	; 1
     442:	cd 91       	ld	r28, X+
     444:	dc 91       	ld	r29, X
     446:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     448:	d3 83       	std	Z+3, r29	; 0x03
     44a:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     44c:	8c 81       	ldd	r24, Y+4	; 0x04
     44e:	9d 81       	ldd	r25, Y+5	; 0x05
     450:	95 83       	std	Z+5, r25	; 0x05
     452:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     454:	8c 81       	ldd	r24, Y+4	; 0x04
     456:	9d 81       	ldd	r25, Y+5	; 0x05
     458:	dc 01       	movw	r26, r24
     45a:	13 96       	adiw	r26, 0x03	; 3
     45c:	7c 93       	st	X, r23
     45e:	6e 93       	st	-X, r22
     460:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
     462:	7d 83       	std	Y+5, r23	; 0x05
     464:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     466:	31 87       	std	Z+9, r19	; 0x09
     468:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
     46a:	f9 01       	movw	r30, r18
     46c:	80 81       	ld	r24, Z
     46e:	8f 5f       	subi	r24, 0xFF	; 255
     470:	80 83       	st	Z, r24
}
     472:	df 91       	pop	r29
     474:	cf 91       	pop	r28
     476:	08 95       	ret

00000478 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     478:	cf 93       	push	r28
     47a:	df 93       	push	r29
     47c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     47e:	48 81       	ld	r20, Y
     480:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     482:	4f 3f       	cpi	r20, 0xFF	; 255
     484:	2f ef       	ldi	r18, 0xFF	; 255
     486:	52 07       	cpc	r21, r18
     488:	21 f4       	brne	.+8      	; 0x492 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     48a:	fc 01       	movw	r30, r24
     48c:	a7 81       	ldd	r26, Z+7	; 0x07
     48e:	b0 85       	ldd	r27, Z+8	; 0x08
     490:	0d c0       	rjmp	.+26     	; 0x4ac <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     492:	dc 01       	movw	r26, r24
     494:	13 96       	adiw	r26, 0x03	; 3
     496:	01 c0       	rjmp	.+2      	; 0x49a <vListInsert+0x22>
     498:	df 01       	movw	r26, r30
     49a:	12 96       	adiw	r26, 0x02	; 2
     49c:	ed 91       	ld	r30, X+
     49e:	fc 91       	ld	r31, X
     4a0:	13 97       	sbiw	r26, 0x03	; 3
     4a2:	20 81       	ld	r18, Z
     4a4:	31 81       	ldd	r19, Z+1	; 0x01
     4a6:	42 17       	cp	r20, r18
     4a8:	53 07       	cpc	r21, r19
     4aa:	b0 f7       	brcc	.-20     	; 0x498 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     4ac:	12 96       	adiw	r26, 0x02	; 2
     4ae:	ed 91       	ld	r30, X+
     4b0:	fc 91       	ld	r31, X
     4b2:	13 97       	sbiw	r26, 0x03	; 3
     4b4:	fb 83       	std	Y+3, r31	; 0x03
     4b6:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4b8:	d5 83       	std	Z+5, r29	; 0x05
     4ba:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     4bc:	bd 83       	std	Y+5, r27	; 0x05
     4be:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
     4c0:	13 96       	adiw	r26, 0x03	; 3
     4c2:	dc 93       	st	X, r29
     4c4:	ce 93       	st	-X, r28
     4c6:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
     4c8:	99 87       	std	Y+9, r25	; 0x09
     4ca:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     4cc:	fc 01       	movw	r30, r24
     4ce:	20 81       	ld	r18, Z
     4d0:	2f 5f       	subi	r18, 0xFF	; 255
     4d2:	20 83       	st	Z, r18
}
     4d4:	df 91       	pop	r29
     4d6:	cf 91       	pop	r28
     4d8:	08 95       	ret

000004da <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4da:	cf 93       	push	r28
     4dc:	df 93       	push	r29
     4de:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     4e0:	a0 85       	ldd	r26, Z+8	; 0x08
     4e2:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4e4:	c2 81       	ldd	r28, Z+2	; 0x02
     4e6:	d3 81       	ldd	r29, Z+3	; 0x03
     4e8:	84 81       	ldd	r24, Z+4	; 0x04
     4ea:	95 81       	ldd	r25, Z+5	; 0x05
     4ec:	9d 83       	std	Y+5, r25	; 0x05
     4ee:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4f0:	c4 81       	ldd	r28, Z+4	; 0x04
     4f2:	d5 81       	ldd	r29, Z+5	; 0x05
     4f4:	82 81       	ldd	r24, Z+2	; 0x02
     4f6:	93 81       	ldd	r25, Z+3	; 0x03
     4f8:	9b 83       	std	Y+3, r25	; 0x03
     4fa:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     4fc:	11 96       	adiw	r26, 0x01	; 1
     4fe:	8d 91       	ld	r24, X+
     500:	9c 91       	ld	r25, X
     502:	12 97       	sbiw	r26, 0x02	; 2
     504:	e8 17       	cp	r30, r24
     506:	f9 07       	cpc	r31, r25
     508:	31 f4       	brne	.+12     	; 0x516 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     50a:	84 81       	ldd	r24, Z+4	; 0x04
     50c:	95 81       	ldd	r25, Z+5	; 0x05
     50e:	12 96       	adiw	r26, 0x02	; 2
     510:	9c 93       	st	X, r25
     512:	8e 93       	st	-X, r24
     514:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     516:	11 86       	std	Z+9, r1	; 0x09
     518:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
     51a:	8c 91       	ld	r24, X
     51c:	81 50       	subi	r24, 0x01	; 1
     51e:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
     520:	8c 91       	ld	r24, X
}
     522:	df 91       	pop	r29
     524:	cf 91       	pop	r28
     526:	08 95       	ret

00000528 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     528:	31 e1       	ldi	r19, 0x11	; 17
     52a:	fc 01       	movw	r30, r24
     52c:	30 83       	st	Z, r19
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	22 e2       	ldi	r18, 0x22	; 34
     532:	20 83       	st	Z, r18
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	a3 e3       	ldi	r26, 0x33	; 51
     538:	a0 83       	st	Z, r26
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	60 83       	st	Z, r22
     53e:	31 97       	sbiw	r30, 0x01	; 1
     540:	70 83       	st	Z, r23
     542:	31 97       	sbiw	r30, 0x01	; 1
     544:	10 82       	st	Z, r1
     546:	31 97       	sbiw	r30, 0x01	; 1
     548:	10 82       	st	Z, r1
     54a:	31 97       	sbiw	r30, 0x01	; 1
     54c:	60 e8       	ldi	r22, 0x80	; 128
     54e:	60 83       	st	Z, r22
     550:	31 97       	sbiw	r30, 0x01	; 1
     552:	10 82       	st	Z, r1
     554:	31 97       	sbiw	r30, 0x01	; 1
     556:	10 82       	st	Z, r1
     558:	31 97       	sbiw	r30, 0x01	; 1
     55a:	10 82       	st	Z, r1
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	62 e0       	ldi	r22, 0x02	; 2
     560:	60 83       	st	Z, r22
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	63 e0       	ldi	r22, 0x03	; 3
     566:	60 83       	st	Z, r22
     568:	31 97       	sbiw	r30, 0x01	; 1
     56a:	64 e0       	ldi	r22, 0x04	; 4
     56c:	60 83       	st	Z, r22
     56e:	31 97       	sbiw	r30, 0x01	; 1
     570:	65 e0       	ldi	r22, 0x05	; 5
     572:	60 83       	st	Z, r22
     574:	31 97       	sbiw	r30, 0x01	; 1
     576:	66 e0       	ldi	r22, 0x06	; 6
     578:	60 83       	st	Z, r22
     57a:	31 97       	sbiw	r30, 0x01	; 1
     57c:	67 e0       	ldi	r22, 0x07	; 7
     57e:	60 83       	st	Z, r22
     580:	31 97       	sbiw	r30, 0x01	; 1
     582:	68 e0       	ldi	r22, 0x08	; 8
     584:	60 83       	st	Z, r22
     586:	31 97       	sbiw	r30, 0x01	; 1
     588:	69 e0       	ldi	r22, 0x09	; 9
     58a:	60 83       	st	Z, r22
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	60 e1       	ldi	r22, 0x10	; 16
     590:	60 83       	st	Z, r22
     592:	31 97       	sbiw	r30, 0x01	; 1
     594:	30 83       	st	Z, r19
     596:	31 97       	sbiw	r30, 0x01	; 1
     598:	32 e1       	ldi	r19, 0x12	; 18
     59a:	30 83       	st	Z, r19
     59c:	31 97       	sbiw	r30, 0x01	; 1
     59e:	33 e1       	ldi	r19, 0x13	; 19
     5a0:	30 83       	st	Z, r19
     5a2:	31 97       	sbiw	r30, 0x01	; 1
     5a4:	34 e1       	ldi	r19, 0x14	; 20
     5a6:	30 83       	st	Z, r19
     5a8:	31 97       	sbiw	r30, 0x01	; 1
     5aa:	35 e1       	ldi	r19, 0x15	; 21
     5ac:	30 83       	st	Z, r19
     5ae:	31 97       	sbiw	r30, 0x01	; 1
     5b0:	36 e1       	ldi	r19, 0x16	; 22
     5b2:	30 83       	st	Z, r19
     5b4:	31 97       	sbiw	r30, 0x01	; 1
     5b6:	37 e1       	ldi	r19, 0x17	; 23
     5b8:	30 83       	st	Z, r19
     5ba:	31 97       	sbiw	r30, 0x01	; 1
     5bc:	38 e1       	ldi	r19, 0x18	; 24
     5be:	30 83       	st	Z, r19
     5c0:	31 97       	sbiw	r30, 0x01	; 1
     5c2:	39 e1       	ldi	r19, 0x19	; 25
     5c4:	30 83       	st	Z, r19
     5c6:	31 97       	sbiw	r30, 0x01	; 1
     5c8:	30 e2       	ldi	r19, 0x20	; 32
     5ca:	30 83       	st	Z, r19
     5cc:	31 97       	sbiw	r30, 0x01	; 1
     5ce:	31 e2       	ldi	r19, 0x21	; 33
     5d0:	30 83       	st	Z, r19
     5d2:	31 97       	sbiw	r30, 0x01	; 1
     5d4:	20 83       	st	Z, r18
     5d6:	31 97       	sbiw	r30, 0x01	; 1
     5d8:	23 e2       	ldi	r18, 0x23	; 35
     5da:	20 83       	st	Z, r18
     5dc:	31 97       	sbiw	r30, 0x01	; 1
     5de:	40 83       	st	Z, r20
     5e0:	31 97       	sbiw	r30, 0x01	; 1
     5e2:	50 83       	st	Z, r21
     5e4:	31 97       	sbiw	r30, 0x01	; 1
     5e6:	26 e2       	ldi	r18, 0x26	; 38
     5e8:	20 83       	st	Z, r18
     5ea:	31 97       	sbiw	r30, 0x01	; 1
     5ec:	27 e2       	ldi	r18, 0x27	; 39
     5ee:	20 83       	st	Z, r18
     5f0:	31 97       	sbiw	r30, 0x01	; 1
     5f2:	28 e2       	ldi	r18, 0x28	; 40
     5f4:	20 83       	st	Z, r18
     5f6:	31 97       	sbiw	r30, 0x01	; 1
     5f8:	29 e2       	ldi	r18, 0x29	; 41
     5fa:	20 83       	st	Z, r18
     5fc:	31 97       	sbiw	r30, 0x01	; 1
     5fe:	20 e3       	ldi	r18, 0x30	; 48
     600:	20 83       	st	Z, r18
     602:	31 97       	sbiw	r30, 0x01	; 1
     604:	21 e3       	ldi	r18, 0x31	; 49
     606:	20 83       	st	Z, r18
     608:	89 97       	sbiw	r24, 0x29	; 41
     60a:	08 95       	ret

0000060c <xPortStartScheduler>:
     60c:	a8 95       	wdr
     60e:	90 ec       	ldi	r25, 0xC0	; 192
     610:	88 e1       	ldi	r24, 0x18	; 24
     612:	0f b6       	in	r0, 0x3f	; 63
     614:	f8 94       	cli
     616:	a8 95       	wdr
     618:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     61c:	0f be       	out	0x3f, r0	; 63
     61e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     622:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     626:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     62a:	cd 91       	ld	r28, X+
     62c:	cd bf       	out	0x3d, r28	; 61
     62e:	dd 91       	ld	r29, X+
     630:	de bf       	out	0x3e, r29	; 62
     632:	ff 91       	pop	r31
     634:	ef 91       	pop	r30
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	bf 91       	pop	r27
     63c:	af 91       	pop	r26
     63e:	9f 91       	pop	r25
     640:	8f 91       	pop	r24
     642:	7f 91       	pop	r23
     644:	6f 91       	pop	r22
     646:	5f 91       	pop	r21
     648:	4f 91       	pop	r20
     64a:	3f 91       	pop	r19
     64c:	2f 91       	pop	r18
     64e:	1f 91       	pop	r17
     650:	0f 91       	pop	r16
     652:	ff 90       	pop	r15
     654:	ef 90       	pop	r14
     656:	df 90       	pop	r13
     658:	cf 90       	pop	r12
     65a:	bf 90       	pop	r11
     65c:	af 90       	pop	r10
     65e:	9f 90       	pop	r9
     660:	8f 90       	pop	r8
     662:	7f 90       	pop	r7
     664:	6f 90       	pop	r6
     666:	5f 90       	pop	r5
     668:	4f 90       	pop	r4
     66a:	3f 90       	pop	r3
     66c:	2f 90       	pop	r2
     66e:	1f 90       	pop	r1
     670:	0f 90       	pop	r0
     672:	0c be       	out	0x3c, r0	; 60
     674:	0f 90       	pop	r0
     676:	0b be       	out	0x3b, r0	; 59
     678:	0f 90       	pop	r0
     67a:	0f be       	out	0x3f, r0	; 63
     67c:	0f 90       	pop	r0
     67e:	08 95       	ret
     680:	81 e0       	ldi	r24, 0x01	; 1
     682:	08 95       	ret

00000684 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
     684:	0f 92       	push	r0
     686:	0f b6       	in	r0, 0x3f	; 63
     688:	f8 94       	cli
     68a:	0f 92       	push	r0
     68c:	0b b6       	in	r0, 0x3b	; 59
     68e:	0f 92       	push	r0
     690:	0c b6       	in	r0, 0x3c	; 60
     692:	0f 92       	push	r0
     694:	1f 92       	push	r1
     696:	11 24       	eor	r1, r1
     698:	2f 92       	push	r2
     69a:	3f 92       	push	r3
     69c:	4f 92       	push	r4
     69e:	5f 92       	push	r5
     6a0:	6f 92       	push	r6
     6a2:	7f 92       	push	r7
     6a4:	8f 92       	push	r8
     6a6:	9f 92       	push	r9
     6a8:	af 92       	push	r10
     6aa:	bf 92       	push	r11
     6ac:	cf 92       	push	r12
     6ae:	df 92       	push	r13
     6b0:	ef 92       	push	r14
     6b2:	ff 92       	push	r15
     6b4:	0f 93       	push	r16
     6b6:	1f 93       	push	r17
     6b8:	2f 93       	push	r18
     6ba:	3f 93       	push	r19
     6bc:	4f 93       	push	r20
     6be:	5f 93       	push	r21
     6c0:	6f 93       	push	r22
     6c2:	7f 93       	push	r23
     6c4:	8f 93       	push	r24
     6c6:	9f 93       	push	r25
     6c8:	af 93       	push	r26
     6ca:	bf 93       	push	r27
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	ef 93       	push	r30
     6d2:	ff 93       	push	r31
     6d4:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     6d8:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     6dc:	0d b6       	in	r0, 0x3d	; 61
     6de:	0d 92       	st	X+, r0
     6e0:	0e b6       	in	r0, 0x3e	; 62
     6e2:	0d 92       	st	X+, r0
    vTaskSwitchContext();
     6e4:	66 d6       	rcall	.+3276   	; 0x13b2 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     6e6:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     6ea:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     6ee:	cd 91       	ld	r28, X+
     6f0:	cd bf       	out	0x3d, r28	; 61
     6f2:	dd 91       	ld	r29, X+
     6f4:	de bf       	out	0x3e, r29	; 62
     6f6:	ff 91       	pop	r31
     6f8:	ef 91       	pop	r30
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	bf 91       	pop	r27
     700:	af 91       	pop	r26
     702:	9f 91       	pop	r25
     704:	8f 91       	pop	r24
     706:	7f 91       	pop	r23
     708:	6f 91       	pop	r22
     70a:	5f 91       	pop	r21
     70c:	4f 91       	pop	r20
     70e:	3f 91       	pop	r19
     710:	2f 91       	pop	r18
     712:	1f 91       	pop	r17
     714:	0f 91       	pop	r16
     716:	ff 90       	pop	r15
     718:	ef 90       	pop	r14
     71a:	df 90       	pop	r13
     71c:	cf 90       	pop	r12
     71e:	bf 90       	pop	r11
     720:	af 90       	pop	r10
     722:	9f 90       	pop	r9
     724:	8f 90       	pop	r8
     726:	7f 90       	pop	r7
     728:	6f 90       	pop	r6
     72a:	5f 90       	pop	r5
     72c:	4f 90       	pop	r4
     72e:	3f 90       	pop	r3
     730:	2f 90       	pop	r2
     732:	1f 90       	pop	r1
     734:	0f 90       	pop	r0
     736:	0c be       	out	0x3c, r0	; 60
     738:	0f 90       	pop	r0
     73a:	0b be       	out	0x3b, r0	; 59
     73c:	0f 90       	pop	r0
     73e:	0f be       	out	0x3f, r0	; 63
     740:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
     742:	08 95       	ret

00000744 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
     744:	0f 92       	push	r0
     746:	0f b6       	in	r0, 0x3f	; 63
     748:	f8 94       	cli
     74a:	0f 92       	push	r0
     74c:	0b b6       	in	r0, 0x3b	; 59
     74e:	0f 92       	push	r0
     750:	0c b6       	in	r0, 0x3c	; 60
     752:	0f 92       	push	r0
     754:	1f 92       	push	r1
     756:	11 24       	eor	r1, r1
     758:	2f 92       	push	r2
     75a:	3f 92       	push	r3
     75c:	4f 92       	push	r4
     75e:	5f 92       	push	r5
     760:	6f 92       	push	r6
     762:	7f 92       	push	r7
     764:	8f 92       	push	r8
     766:	9f 92       	push	r9
     768:	af 92       	push	r10
     76a:	bf 92       	push	r11
     76c:	cf 92       	push	r12
     76e:	df 92       	push	r13
     770:	ef 92       	push	r14
     772:	ff 92       	push	r15
     774:	0f 93       	push	r16
     776:	1f 93       	push	r17
     778:	2f 93       	push	r18
     77a:	3f 93       	push	r19
     77c:	4f 93       	push	r20
     77e:	5f 93       	push	r21
     780:	6f 93       	push	r22
     782:	7f 93       	push	r23
     784:	8f 93       	push	r24
     786:	9f 93       	push	r25
     788:	af 93       	push	r26
     78a:	bf 93       	push	r27
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	ef 93       	push	r30
     792:	ff 93       	push	r31
     794:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     798:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     79c:	0d b6       	in	r0, 0x3d	; 61
     79e:	0d 92       	st	X+, r0
     7a0:	0e b6       	in	r0, 0x3e	; 62
     7a2:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
     7a4:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
     7a6:	b6 d4       	rcall	.+2412   	; 0x1114 <xTaskIncrementTick>
     7a8:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
     7aa:	03 d6       	rcall	.+3078   	; 0x13b2 <vTaskSwitchContext>
     7ac:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    }

    portRESTORE_CONTEXT();
     7b0:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     7b4:	cd 91       	ld	r28, X+
     7b6:	cd bf       	out	0x3d, r28	; 61
     7b8:	dd 91       	ld	r29, X+
     7ba:	de bf       	out	0x3e, r29	; 62
     7bc:	ff 91       	pop	r31
     7be:	ef 91       	pop	r30
     7c0:	df 91       	pop	r29
     7c2:	cf 91       	pop	r28
     7c4:	bf 91       	pop	r27
     7c6:	af 91       	pop	r26
     7c8:	9f 91       	pop	r25
     7ca:	8f 91       	pop	r24
     7cc:	7f 91       	pop	r23
     7ce:	6f 91       	pop	r22
     7d0:	5f 91       	pop	r21
     7d2:	4f 91       	pop	r20
     7d4:	3f 91       	pop	r19
     7d6:	2f 91       	pop	r18
     7d8:	1f 91       	pop	r17
     7da:	0f 91       	pop	r16
     7dc:	ff 90       	pop	r15
     7de:	ef 90       	pop	r14
     7e0:	df 90       	pop	r13
     7e2:	cf 90       	pop	r12
     7e4:	bf 90       	pop	r11
     7e6:	af 90       	pop	r10
     7e8:	9f 90       	pop	r9
     7ea:	8f 90       	pop	r8
     7ec:	7f 90       	pop	r7
     7ee:	6f 90       	pop	r6
     7f0:	5f 90       	pop	r5
     7f2:	4f 90       	pop	r4
     7f4:	3f 90       	pop	r3
     7f6:	2f 90       	pop	r2
     7f8:	1f 90       	pop	r1
     7fa:	0f 90       	pop	r0
     7fc:	0c be       	out	0x3c, r0	; 60
     7fe:	0f 90       	pop	r0
     800:	0b be       	out	0x3b, r0	; 59
     802:	0f 90       	pop	r0
     804:	0f be       	out	0x3f, r0	; 63
     806:	0f 90       	pop	r0
     808:	08 95       	ret

0000080a <__vector_12>:

    __asm__ __volatile__ ( "ret" );
     80a:	9c df       	rcall	.-200    	; 0x744 <vPortYieldFromTick>
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
        __asm__ __volatile__ ( "reti" );
     80c:	18 95       	reti

0000080e <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	0f 92       	push	r0
     814:	fc 01       	movw	r30, r24
     816:	92 8d       	ldd	r25, Z+26	; 0x1a
     818:	0f 90       	pop	r0
     81a:	0f be       	out	0x3f, r0	; 63
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	91 11       	cpse	r25, r1
     820:	80 e0       	ldi	r24, 0x00	; 0
     822:	08 95       	ret

00000824 <prvCopyDataToQueue>:
     824:	0f 93       	push	r16
     826:	1f 93       	push	r17
     828:	cf 93       	push	r28
     82a:	df 93       	push	r29
     82c:	ec 01       	movw	r28, r24
     82e:	04 2f       	mov	r16, r20
     830:	1a 8d       	ldd	r17, Y+26	; 0x1a
     832:	4c 8d       	ldd	r20, Y+28	; 0x1c
     834:	41 11       	cpse	r20, r1
     836:	0b c0       	rjmp	.+22     	; 0x84e <prvCopyDataToQueue+0x2a>
     838:	88 81       	ld	r24, Y
     83a:	99 81       	ldd	r25, Y+1	; 0x01
     83c:	89 2b       	or	r24, r25
     83e:	09 f0       	breq	.+2      	; 0x842 <prvCopyDataToQueue+0x1e>
     840:	41 c0       	rjmp	.+130    	; 0x8c4 <prvCopyDataToQueue+0xa0>
     842:	8c 81       	ldd	r24, Y+4	; 0x04
     844:	9d 81       	ldd	r25, Y+5	; 0x05
     846:	06 d7       	rcall	.+3596   	; 0x1654 <xTaskPriorityDisinherit>
     848:	1d 82       	std	Y+5, r1	; 0x05
     84a:	1c 82       	std	Y+4, r1	; 0x04
     84c:	42 c0       	rjmp	.+132    	; 0x8d2 <prvCopyDataToQueue+0xae>
     84e:	01 11       	cpse	r16, r1
     850:	17 c0       	rjmp	.+46     	; 0x880 <prvCopyDataToQueue+0x5c>
     852:	50 e0       	ldi	r21, 0x00	; 0
     854:	8a 81       	ldd	r24, Y+2	; 0x02
     856:	9b 81       	ldd	r25, Y+3	; 0x03
     858:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <memcpy>
     85c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     85e:	8a 81       	ldd	r24, Y+2	; 0x02
     860:	9b 81       	ldd	r25, Y+3	; 0x03
     862:	82 0f       	add	r24, r18
     864:	91 1d       	adc	r25, r1
     866:	9b 83       	std	Y+3, r25	; 0x03
     868:	8a 83       	std	Y+2, r24	; 0x02
     86a:	2c 81       	ldd	r18, Y+4	; 0x04
     86c:	3d 81       	ldd	r19, Y+5	; 0x05
     86e:	82 17       	cp	r24, r18
     870:	93 07       	cpc	r25, r19
     872:	50 f1       	brcs	.+84     	; 0x8c8 <prvCopyDataToQueue+0xa4>
     874:	88 81       	ld	r24, Y
     876:	99 81       	ldd	r25, Y+1	; 0x01
     878:	9b 83       	std	Y+3, r25	; 0x03
     87a:	8a 83       	std	Y+2, r24	; 0x02
     87c:	80 e0       	ldi	r24, 0x00	; 0
     87e:	29 c0       	rjmp	.+82     	; 0x8d2 <prvCopyDataToQueue+0xae>
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	8e 81       	ldd	r24, Y+6	; 0x06
     884:	9f 81       	ldd	r25, Y+7	; 0x07
     886:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <memcpy>
     88a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     88c:	90 e0       	ldi	r25, 0x00	; 0
     88e:	91 95       	neg	r25
     890:	81 95       	neg	r24
     892:	91 09       	sbc	r25, r1
     894:	2e 81       	ldd	r18, Y+6	; 0x06
     896:	3f 81       	ldd	r19, Y+7	; 0x07
     898:	28 0f       	add	r18, r24
     89a:	39 1f       	adc	r19, r25
     89c:	3f 83       	std	Y+7, r19	; 0x07
     89e:	2e 83       	std	Y+6, r18	; 0x06
     8a0:	48 81       	ld	r20, Y
     8a2:	59 81       	ldd	r21, Y+1	; 0x01
     8a4:	24 17       	cp	r18, r20
     8a6:	35 07       	cpc	r19, r21
     8a8:	30 f4       	brcc	.+12     	; 0x8b6 <prvCopyDataToQueue+0x92>
     8aa:	2c 81       	ldd	r18, Y+4	; 0x04
     8ac:	3d 81       	ldd	r19, Y+5	; 0x05
     8ae:	82 0f       	add	r24, r18
     8b0:	93 1f       	adc	r25, r19
     8b2:	9f 83       	std	Y+7, r25	; 0x07
     8b4:	8e 83       	std	Y+6, r24	; 0x06
     8b6:	02 30       	cpi	r16, 0x02	; 2
     8b8:	49 f4       	brne	.+18     	; 0x8cc <prvCopyDataToQueue+0xa8>
     8ba:	11 23       	and	r17, r17
     8bc:	49 f0       	breq	.+18     	; 0x8d0 <prvCopyDataToQueue+0xac>
     8be:	11 50       	subi	r17, 0x01	; 1
     8c0:	80 e0       	ldi	r24, 0x00	; 0
     8c2:	07 c0       	rjmp	.+14     	; 0x8d2 <prvCopyDataToQueue+0xae>
     8c4:	80 e0       	ldi	r24, 0x00	; 0
     8c6:	05 c0       	rjmp	.+10     	; 0x8d2 <prvCopyDataToQueue+0xae>
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	03 c0       	rjmp	.+6      	; 0x8d2 <prvCopyDataToQueue+0xae>
     8cc:	80 e0       	ldi	r24, 0x00	; 0
     8ce:	01 c0       	rjmp	.+2      	; 0x8d2 <prvCopyDataToQueue+0xae>
     8d0:	80 e0       	ldi	r24, 0x00	; 0
     8d2:	1f 5f       	subi	r17, 0xFF	; 255
     8d4:	1a 8f       	std	Y+26, r17	; 0x1a
     8d6:	df 91       	pop	r29
     8d8:	cf 91       	pop	r28
     8da:	1f 91       	pop	r17
     8dc:	0f 91       	pop	r16
     8de:	08 95       	ret

000008e0 <prvCopyDataFromQueue>:
     8e0:	fc 01       	movw	r30, r24
     8e2:	44 8d       	ldd	r20, Z+28	; 0x1c
     8e4:	44 23       	and	r20, r20
     8e6:	a9 f0       	breq	.+42     	; 0x912 <prvCopyDataFromQueue+0x32>
     8e8:	50 e0       	ldi	r21, 0x00	; 0
     8ea:	26 81       	ldd	r18, Z+6	; 0x06
     8ec:	37 81       	ldd	r19, Z+7	; 0x07
     8ee:	24 0f       	add	r18, r20
     8f0:	35 1f       	adc	r19, r21
     8f2:	37 83       	std	Z+7, r19	; 0x07
     8f4:	26 83       	std	Z+6, r18	; 0x06
     8f6:	84 81       	ldd	r24, Z+4	; 0x04
     8f8:	95 81       	ldd	r25, Z+5	; 0x05
     8fa:	28 17       	cp	r18, r24
     8fc:	39 07       	cpc	r19, r25
     8fe:	20 f0       	brcs	.+8      	; 0x908 <prvCopyDataFromQueue+0x28>
     900:	80 81       	ld	r24, Z
     902:	91 81       	ldd	r25, Z+1	; 0x01
     904:	97 83       	std	Z+7, r25	; 0x07
     906:	86 83       	std	Z+6, r24	; 0x06
     908:	cb 01       	movw	r24, r22
     90a:	66 81       	ldd	r22, Z+6	; 0x06
     90c:	77 81       	ldd	r23, Z+7	; 0x07
     90e:	0c 94 39 0e 	jmp	0x1c72	; 0x1c72 <memcpy>
     912:	08 95       	ret

00000914 <prvUnlockQueue>:
     914:	ef 92       	push	r14
     916:	ff 92       	push	r15
     918:	0f 93       	push	r16
     91a:	1f 93       	push	r17
     91c:	cf 93       	push	r28
     91e:	8c 01       	movw	r16, r24
     920:	0f b6       	in	r0, 0x3f	; 63
     922:	f8 94       	cli
     924:	0f 92       	push	r0
     926:	fc 01       	movw	r30, r24
     928:	c6 8d       	ldd	r28, Z+30	; 0x1e
     92a:	1c 16       	cp	r1, r28
     92c:	9c f4       	brge	.+38     	; 0x954 <prvUnlockQueue+0x40>
     92e:	81 89       	ldd	r24, Z+17	; 0x11
     930:	81 11       	cpse	r24, r1
     932:	06 c0       	rjmp	.+12     	; 0x940 <prvUnlockQueue+0x2c>
     934:	0f c0       	rjmp	.+30     	; 0x954 <prvUnlockQueue+0x40>
     936:	f8 01       	movw	r30, r16
     938:	81 89       	ldd	r24, Z+17	; 0x11
     93a:	81 11       	cpse	r24, r1
     93c:	05 c0       	rjmp	.+10     	; 0x948 <prvUnlockQueue+0x34>
     93e:	0a c0       	rjmp	.+20     	; 0x954 <prvUnlockQueue+0x40>
     940:	78 01       	movw	r14, r16
     942:	f1 e1       	ldi	r31, 0x11	; 17
     944:	ef 0e       	add	r14, r31
     946:	f1 1c       	adc	r15, r1
     948:	c7 01       	movw	r24, r14
     94a:	ea d5       	rcall	.+3028   	; 0x1520 <xTaskRemoveFromEventList>
     94c:	81 11       	cpse	r24, r1
     94e:	70 d6       	rcall	.+3296   	; 0x1630 <vTaskMissedYield>
     950:	c1 50       	subi	r28, 0x01	; 1
     952:	89 f7       	brne	.-30     	; 0x936 <prvUnlockQueue+0x22>
     954:	8f ef       	ldi	r24, 0xFF	; 255
     956:	f8 01       	movw	r30, r16
     958:	86 8f       	std	Z+30, r24	; 0x1e
     95a:	0f 90       	pop	r0
     95c:	0f be       	out	0x3f, r0	; 63
     95e:	0f b6       	in	r0, 0x3f	; 63
     960:	f8 94       	cli
     962:	0f 92       	push	r0
     964:	c5 8d       	ldd	r28, Z+29	; 0x1d
     966:	1c 16       	cp	r1, r28
     968:	9c f4       	brge	.+38     	; 0x990 <prvUnlockQueue+0x7c>
     96a:	80 85       	ldd	r24, Z+8	; 0x08
     96c:	81 11       	cpse	r24, r1
     96e:	06 c0       	rjmp	.+12     	; 0x97c <prvUnlockQueue+0x68>
     970:	0f c0       	rjmp	.+30     	; 0x990 <prvUnlockQueue+0x7c>
     972:	f8 01       	movw	r30, r16
     974:	80 85       	ldd	r24, Z+8	; 0x08
     976:	81 11       	cpse	r24, r1
     978:	05 c0       	rjmp	.+10     	; 0x984 <prvUnlockQueue+0x70>
     97a:	0a c0       	rjmp	.+20     	; 0x990 <prvUnlockQueue+0x7c>
     97c:	78 01       	movw	r14, r16
     97e:	f8 e0       	ldi	r31, 0x08	; 8
     980:	ef 0e       	add	r14, r31
     982:	f1 1c       	adc	r15, r1
     984:	c7 01       	movw	r24, r14
     986:	cc d5       	rcall	.+2968   	; 0x1520 <xTaskRemoveFromEventList>
     988:	81 11       	cpse	r24, r1
     98a:	52 d6       	rcall	.+3236   	; 0x1630 <vTaskMissedYield>
     98c:	c1 50       	subi	r28, 0x01	; 1
     98e:	89 f7       	brne	.-30     	; 0x972 <prvUnlockQueue+0x5e>
     990:	8f ef       	ldi	r24, 0xFF	; 255
     992:	f8 01       	movw	r30, r16
     994:	85 8f       	std	Z+29, r24	; 0x1d
     996:	0f 90       	pop	r0
     998:	0f be       	out	0x3f, r0	; 63
     99a:	cf 91       	pop	r28
     99c:	1f 91       	pop	r17
     99e:	0f 91       	pop	r16
     9a0:	ff 90       	pop	r15
     9a2:	ef 90       	pop	r14
     9a4:	08 95       	ret

000009a6 <xQueueGenericReset>:
     9a6:	cf 93       	push	r28
     9a8:	df 93       	push	r29
     9aa:	ec 01       	movw	r28, r24
     9ac:	0f b6       	in	r0, 0x3f	; 63
     9ae:	f8 94       	cli
     9b0:	0f 92       	push	r0
     9b2:	e8 81       	ld	r30, Y
     9b4:	f9 81       	ldd	r31, Y+1	; 0x01
     9b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     9b8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     9ba:	90 e0       	ldi	r25, 0x00	; 0
     9bc:	30 e0       	ldi	r19, 0x00	; 0
     9be:	82 9f       	mul	r24, r18
     9c0:	a0 01       	movw	r20, r0
     9c2:	83 9f       	mul	r24, r19
     9c4:	50 0d       	add	r21, r0
     9c6:	92 9f       	mul	r25, r18
     9c8:	50 0d       	add	r21, r0
     9ca:	11 24       	eor	r1, r1
     9cc:	4e 0f       	add	r20, r30
     9ce:	5f 1f       	adc	r21, r31
     9d0:	5d 83       	std	Y+5, r21	; 0x05
     9d2:	4c 83       	std	Y+4, r20	; 0x04
     9d4:	1a 8e       	std	Y+26, r1	; 0x1a
     9d6:	fb 83       	std	Y+3, r31	; 0x03
     9d8:	ea 83       	std	Y+2, r30	; 0x02
     9da:	01 97       	sbiw	r24, 0x01	; 1
     9dc:	82 9f       	mul	r24, r18
     9de:	a0 01       	movw	r20, r0
     9e0:	83 9f       	mul	r24, r19
     9e2:	50 0d       	add	r21, r0
     9e4:	92 9f       	mul	r25, r18
     9e6:	50 0d       	add	r21, r0
     9e8:	11 24       	eor	r1, r1
     9ea:	cf 01       	movw	r24, r30
     9ec:	84 0f       	add	r24, r20
     9ee:	95 1f       	adc	r25, r21
     9f0:	9f 83       	std	Y+7, r25	; 0x07
     9f2:	8e 83       	std	Y+6, r24	; 0x06
     9f4:	8f ef       	ldi	r24, 0xFF	; 255
     9f6:	8d 8f       	std	Y+29, r24	; 0x1d
     9f8:	8e 8f       	std	Y+30, r24	; 0x1e
     9fa:	61 11       	cpse	r22, r1
     9fc:	0a c0       	rjmp	.+20     	; 0xa12 <xQueueGenericReset+0x6c>
     9fe:	88 85       	ldd	r24, Y+8	; 0x08
     a00:	88 23       	and	r24, r24
     a02:	69 f0       	breq	.+26     	; 0xa1e <xQueueGenericReset+0x78>
     a04:	ce 01       	movw	r24, r28
     a06:	08 96       	adiw	r24, 0x08	; 8
     a08:	8b d5       	rcall	.+2838   	; 0x1520 <xTaskRemoveFromEventList>
     a0a:	88 23       	and	r24, r24
     a0c:	41 f0       	breq	.+16     	; 0xa1e <xQueueGenericReset+0x78>
     a0e:	3a de       	rcall	.-908    	; 0x684 <vPortYield>
     a10:	06 c0       	rjmp	.+12     	; 0xa1e <xQueueGenericReset+0x78>
     a12:	ce 01       	movw	r24, r28
     a14:	08 96       	adiw	r24, 0x08	; 8
     a16:	fd dc       	rcall	.-1542   	; 0x412 <vListInitialise>
     a18:	ce 01       	movw	r24, r28
     a1a:	41 96       	adiw	r24, 0x11	; 17
     a1c:	fa dc       	rcall	.-1548   	; 0x412 <vListInitialise>
     a1e:	0f 90       	pop	r0
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	df 91       	pop	r29
     a26:	cf 91       	pop	r28
     a28:	08 95       	ret

00000a2a <xQueueGenericCreate>:
     a2a:	ff 92       	push	r15
     a2c:	0f 93       	push	r16
     a2e:	1f 93       	push	r17
     a30:	cf 93       	push	r28
     a32:	df 93       	push	r29
     a34:	08 2f       	mov	r16, r24
     a36:	16 2f       	mov	r17, r22
     a38:	f4 2e       	mov	r15, r20
     a3a:	66 23       	and	r22, r22
     a3c:	b9 f0       	breq	.+46     	; 0xa6c <xQueueGenericCreate+0x42>
     a3e:	86 9f       	mul	r24, r22
     a40:	c0 01       	movw	r24, r0
     a42:	11 24       	eor	r1, r1
     a44:	81 96       	adiw	r24, 0x21	; 33
     a46:	c7 dc       	rcall	.-1650   	; 0x3d6 <pvPortMalloc>
     a48:	ec 01       	movw	r28, r24
     a4a:	00 97       	sbiw	r24, 0x00	; 0
     a4c:	41 f4       	brne	.+16     	; 0xa5e <xQueueGenericCreate+0x34>
     a4e:	14 c0       	rjmp	.+40     	; 0xa78 <xQueueGenericCreate+0x4e>
     a50:	0b 8f       	std	Y+27, r16	; 0x1b
     a52:	1c 8f       	std	Y+28, r17	; 0x1c
     a54:	61 e0       	ldi	r22, 0x01	; 1
     a56:	ce 01       	movw	r24, r28
     a58:	a6 df       	rcall	.-180    	; 0x9a6 <xQueueGenericReset>
     a5a:	f8 a2       	std	Y+32, r15	; 0x20
     a5c:	0d c0       	rjmp	.+26     	; 0xa78 <xQueueGenericCreate+0x4e>
     a5e:	81 96       	adiw	r24, 0x21	; 33
     a60:	99 83       	std	Y+1, r25	; 0x01
     a62:	88 83       	st	Y, r24
     a64:	f5 cf       	rjmp	.-22     	; 0xa50 <xQueueGenericCreate+0x26>
     a66:	d9 83       	std	Y+1, r29	; 0x01
     a68:	c8 83       	st	Y, r28
     a6a:	f2 cf       	rjmp	.-28     	; 0xa50 <xQueueGenericCreate+0x26>
     a6c:	81 e2       	ldi	r24, 0x21	; 33
     a6e:	90 e0       	ldi	r25, 0x00	; 0
     a70:	b2 dc       	rcall	.-1692   	; 0x3d6 <pvPortMalloc>
     a72:	ec 01       	movw	r28, r24
     a74:	89 2b       	or	r24, r25
     a76:	b9 f7       	brne	.-18     	; 0xa66 <xQueueGenericCreate+0x3c>
     a78:	ce 01       	movw	r24, r28
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	1f 91       	pop	r17
     a80:	0f 91       	pop	r16
     a82:	ff 90       	pop	r15
     a84:	08 95       	ret

00000a86 <xQueueGenericSend>:
     a86:	9f 92       	push	r9
     a88:	af 92       	push	r10
     a8a:	bf 92       	push	r11
     a8c:	cf 92       	push	r12
     a8e:	df 92       	push	r13
     a90:	ef 92       	push	r14
     a92:	ff 92       	push	r15
     a94:	0f 93       	push	r16
     a96:	1f 93       	push	r17
     a98:	cf 93       	push	r28
     a9a:	df 93       	push	r29
     a9c:	00 d0       	rcall	.+0      	; 0xa9e <xQueueGenericSend+0x18>
     a9e:	1f 92       	push	r1
     aa0:	1f 92       	push	r1
     aa2:	cd b7       	in	r28, 0x3d	; 61
     aa4:	de b7       	in	r29, 0x3e	; 62
     aa6:	8c 01       	movw	r16, r24
     aa8:	6b 01       	movw	r12, r22
     aaa:	5d 83       	std	Y+5, r21	; 0x05
     aac:	4c 83       	std	Y+4, r20	; 0x04
     aae:	a2 2e       	mov	r10, r18
     ab0:	b1 2c       	mov	r11, r1
     ab2:	99 24       	eor	r9, r9
     ab4:	93 94       	inc	r9
     ab6:	7c 01       	movw	r14, r24
     ab8:	88 e0       	ldi	r24, 0x08	; 8
     aba:	e8 0e       	add	r14, r24
     abc:	f1 1c       	adc	r15, r1
     abe:	0f b6       	in	r0, 0x3f	; 63
     ac0:	f8 94       	cli
     ac2:	0f 92       	push	r0
     ac4:	f8 01       	movw	r30, r16
     ac6:	92 8d       	ldd	r25, Z+26	; 0x1a
     ac8:	83 8d       	ldd	r24, Z+27	; 0x1b
     aca:	98 17       	cp	r25, r24
     acc:	18 f0       	brcs	.+6      	; 0xad4 <xQueueGenericSend+0x4e>
     ace:	f2 e0       	ldi	r31, 0x02	; 2
     ad0:	af 12       	cpse	r10, r31
     ad2:	15 c0       	rjmp	.+42     	; 0xafe <xQueueGenericSend+0x78>
     ad4:	4a 2d       	mov	r20, r10
     ad6:	b6 01       	movw	r22, r12
     ad8:	c8 01       	movw	r24, r16
     ada:	a4 de       	rcall	.-696    	; 0x824 <prvCopyDataToQueue>
     adc:	f8 01       	movw	r30, r16
     ade:	91 89       	ldd	r25, Z+17	; 0x11
     ae0:	99 23       	and	r25, r25
     ae2:	39 f0       	breq	.+14     	; 0xaf2 <xQueueGenericSend+0x6c>
     ae4:	c8 01       	movw	r24, r16
     ae6:	41 96       	adiw	r24, 0x11	; 17
     ae8:	1b d5       	rcall	.+2614   	; 0x1520 <xTaskRemoveFromEventList>
     aea:	88 23       	and	r24, r24
     aec:	21 f0       	breq	.+8      	; 0xaf6 <xQueueGenericSend+0x70>
     aee:	ca dd       	rcall	.-1132   	; 0x684 <vPortYield>
     af0:	02 c0       	rjmp	.+4      	; 0xaf6 <xQueueGenericSend+0x70>
     af2:	81 11       	cpse	r24, r1
     af4:	c7 dd       	rcall	.-1138   	; 0x684 <vPortYield>
     af6:	0f 90       	pop	r0
     af8:	0f be       	out	0x3f, r0	; 63
     afa:	81 e0       	ldi	r24, 0x01	; 1
     afc:	45 c0       	rjmp	.+138    	; 0xb88 <xQueueGenericSend+0x102>
     afe:	8c 81       	ldd	r24, Y+4	; 0x04
     b00:	9d 81       	ldd	r25, Y+5	; 0x05
     b02:	89 2b       	or	r24, r25
     b04:	21 f4       	brne	.+8      	; 0xb0e <xQueueGenericSend+0x88>
     b06:	0f 90       	pop	r0
     b08:	0f be       	out	0x3f, r0	; 63
     b0a:	80 e0       	ldi	r24, 0x00	; 0
     b0c:	3d c0       	rjmp	.+122    	; 0xb88 <xQueueGenericSend+0x102>
     b0e:	b1 10       	cpse	r11, r1
     b10:	04 c0       	rjmp	.+8      	; 0xb1a <xQueueGenericSend+0x94>
     b12:	ce 01       	movw	r24, r28
     b14:	01 96       	adiw	r24, 0x01	; 1
     b16:	4c d5       	rcall	.+2712   	; 0x15b0 <vTaskInternalSetTimeOutState>
     b18:	b9 2c       	mov	r11, r9
     b1a:	0f 90       	pop	r0
     b1c:	0f be       	out	0x3f, r0	; 63
     b1e:	ea d2       	rcall	.+1492   	; 0x10f4 <vTaskSuspendAll>
     b20:	0f b6       	in	r0, 0x3f	; 63
     b22:	f8 94       	cli
     b24:	0f 92       	push	r0
     b26:	f8 01       	movw	r30, r16
     b28:	85 8d       	ldd	r24, Z+29	; 0x1d
     b2a:	8f 3f       	cpi	r24, 0xFF	; 255
     b2c:	09 f4       	brne	.+2      	; 0xb30 <xQueueGenericSend+0xaa>
     b2e:	15 8e       	std	Z+29, r1	; 0x1d
     b30:	f8 01       	movw	r30, r16
     b32:	86 8d       	ldd	r24, Z+30	; 0x1e
     b34:	8f 3f       	cpi	r24, 0xFF	; 255
     b36:	09 f4       	brne	.+2      	; 0xb3a <xQueueGenericSend+0xb4>
     b38:	16 8e       	std	Z+30, r1	; 0x1e
     b3a:	0f 90       	pop	r0
     b3c:	0f be       	out	0x3f, r0	; 63
     b3e:	be 01       	movw	r22, r28
     b40:	6c 5f       	subi	r22, 0xFC	; 252
     b42:	7f 4f       	sbci	r23, 0xFF	; 255
     b44:	ce 01       	movw	r24, r28
     b46:	01 96       	adiw	r24, 0x01	; 1
     b48:	3e d5       	rcall	.+2684   	; 0x15c6 <xTaskCheckForTimeOut>
     b4a:	81 11       	cpse	r24, r1
     b4c:	19 c0       	rjmp	.+50     	; 0xb80 <xQueueGenericSend+0xfa>
     b4e:	0f b6       	in	r0, 0x3f	; 63
     b50:	f8 94       	cli
     b52:	0f 92       	push	r0
     b54:	f8 01       	movw	r30, r16
     b56:	92 8d       	ldd	r25, Z+26	; 0x1a
     b58:	83 8d       	ldd	r24, Z+27	; 0x1b
     b5a:	0f 90       	pop	r0
     b5c:	0f be       	out	0x3f, r0	; 63
     b5e:	98 13       	cpse	r25, r24
     b60:	0b c0       	rjmp	.+22     	; 0xb78 <xQueueGenericSend+0xf2>
     b62:	6c 81       	ldd	r22, Y+4	; 0x04
     b64:	7d 81       	ldd	r23, Y+5	; 0x05
     b66:	c7 01       	movw	r24, r14
     b68:	b2 d4       	rcall	.+2404   	; 0x14ce <vTaskPlaceOnEventList>
     b6a:	c8 01       	movw	r24, r16
     b6c:	d3 de       	rcall	.-602    	; 0x914 <prvUnlockQueue>
     b6e:	89 d3       	rcall	.+1810   	; 0x1282 <xTaskResumeAll>
     b70:	81 11       	cpse	r24, r1
     b72:	a5 cf       	rjmp	.-182    	; 0xabe <xQueueGenericSend+0x38>
     b74:	87 dd       	rcall	.-1266   	; 0x684 <vPortYield>
     b76:	a3 cf       	rjmp	.-186    	; 0xabe <xQueueGenericSend+0x38>
     b78:	c8 01       	movw	r24, r16
     b7a:	cc de       	rcall	.-616    	; 0x914 <prvUnlockQueue>
     b7c:	82 d3       	rcall	.+1796   	; 0x1282 <xTaskResumeAll>
     b7e:	9f cf       	rjmp	.-194    	; 0xabe <xQueueGenericSend+0x38>
     b80:	c8 01       	movw	r24, r16
     b82:	c8 de       	rcall	.-624    	; 0x914 <prvUnlockQueue>
     b84:	7e d3       	rcall	.+1788   	; 0x1282 <xTaskResumeAll>
     b86:	80 e0       	ldi	r24, 0x00	; 0
     b88:	0f 90       	pop	r0
     b8a:	0f 90       	pop	r0
     b8c:	0f 90       	pop	r0
     b8e:	0f 90       	pop	r0
     b90:	0f 90       	pop	r0
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	1f 91       	pop	r17
     b98:	0f 91       	pop	r16
     b9a:	ff 90       	pop	r15
     b9c:	ef 90       	pop	r14
     b9e:	df 90       	pop	r13
     ba0:	cf 90       	pop	r12
     ba2:	bf 90       	pop	r11
     ba4:	af 90       	pop	r10
     ba6:	9f 90       	pop	r9
     ba8:	08 95       	ret

00000baa <xQueueCreateMutex>:
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	48 2f       	mov	r20, r24
     bb0:	60 e0       	ldi	r22, 0x00	; 0
     bb2:	81 e0       	ldi	r24, 0x01	; 1
     bb4:	3a df       	rcall	.-396    	; 0xa2a <xQueueGenericCreate>
     bb6:	ec 01       	movw	r28, r24
     bb8:	00 97       	sbiw	r24, 0x00	; 0
     bba:	59 f0       	breq	.+22     	; 0xbd2 <xQueueCreateMutex+0x28>
     bbc:	1d 82       	std	Y+5, r1	; 0x05
     bbe:	1c 82       	std	Y+4, r1	; 0x04
     bc0:	19 82       	std	Y+1, r1	; 0x01
     bc2:	18 82       	st	Y, r1
     bc4:	1e 82       	std	Y+6, r1	; 0x06
     bc6:	20 e0       	ldi	r18, 0x00	; 0
     bc8:	40 e0       	ldi	r20, 0x00	; 0
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	60 e0       	ldi	r22, 0x00	; 0
     bce:	70 e0       	ldi	r23, 0x00	; 0
     bd0:	5a df       	rcall	.-332    	; 0xa86 <xQueueGenericSend>
     bd2:	ce 01       	movw	r24, r28
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	08 95       	ret

00000bda <xQueueGenericSendFromISR>:
     bda:	ef 92       	push	r14
     bdc:	ff 92       	push	r15
     bde:	0f 93       	push	r16
     be0:	1f 93       	push	r17
     be2:	cf 93       	push	r28
     be4:	df 93       	push	r29
     be6:	8a 01       	movw	r16, r20
     be8:	fc 01       	movw	r30, r24
     bea:	52 8d       	ldd	r21, Z+26	; 0x1a
     bec:	33 8d       	ldd	r19, Z+27	; 0x1b
     bee:	53 17       	cp	r21, r19
     bf0:	10 f0       	brcs	.+4      	; 0xbf6 <xQueueGenericSendFromISR+0x1c>
     bf2:	22 30       	cpi	r18, 0x02	; 2
     bf4:	e1 f4       	brne	.+56     	; 0xc2e <xQueueGenericSendFromISR+0x54>
     bf6:	42 2f       	mov	r20, r18
     bf8:	78 01       	movw	r14, r16
     bfa:	ec 01       	movw	r28, r24
     bfc:	1e 8d       	ldd	r17, Y+30	; 0x1e
     bfe:	12 de       	rcall	.-988    	; 0x824 <prvCopyDataToQueue>
     c00:	1f 3f       	cpi	r17, 0xFF	; 255
     c02:	79 f4       	brne	.+30     	; 0xc22 <xQueueGenericSendFromISR+0x48>
     c04:	89 89       	ldd	r24, Y+17	; 0x11
     c06:	88 23       	and	r24, r24
     c08:	a1 f0       	breq	.+40     	; 0xc32 <xQueueGenericSendFromISR+0x58>
     c0a:	ce 01       	movw	r24, r28
     c0c:	41 96       	adiw	r24, 0x11	; 17
     c0e:	88 d4       	rcall	.+2320   	; 0x1520 <xTaskRemoveFromEventList>
     c10:	88 23       	and	r24, r24
     c12:	89 f0       	breq	.+34     	; 0xc36 <xQueueGenericSendFromISR+0x5c>
     c14:	e1 14       	cp	r14, r1
     c16:	f1 04       	cpc	r15, r1
     c18:	81 f0       	breq	.+32     	; 0xc3a <xQueueGenericSendFromISR+0x60>
     c1a:	81 e0       	ldi	r24, 0x01	; 1
     c1c:	f7 01       	movw	r30, r14
     c1e:	80 83       	st	Z, r24
     c20:	0d c0       	rjmp	.+26     	; 0xc3c <xQueueGenericSendFromISR+0x62>
     c22:	ff 24       	eor	r15, r15
     c24:	f3 94       	inc	r15
     c26:	f1 0e       	add	r15, r17
     c28:	fe 8e       	std	Y+30, r15	; 0x1e
     c2a:	81 e0       	ldi	r24, 0x01	; 1
     c2c:	07 c0       	rjmp	.+14     	; 0xc3c <xQueueGenericSendFromISR+0x62>
     c2e:	80 e0       	ldi	r24, 0x00	; 0
     c30:	05 c0       	rjmp	.+10     	; 0xc3c <xQueueGenericSendFromISR+0x62>
     c32:	81 e0       	ldi	r24, 0x01	; 1
     c34:	03 c0       	rjmp	.+6      	; 0xc3c <xQueueGenericSendFromISR+0x62>
     c36:	81 e0       	ldi	r24, 0x01	; 1
     c38:	01 c0       	rjmp	.+2      	; 0xc3c <xQueueGenericSendFromISR+0x62>
     c3a:	81 e0       	ldi	r24, 0x01	; 1
     c3c:	df 91       	pop	r29
     c3e:	cf 91       	pop	r28
     c40:	1f 91       	pop	r17
     c42:	0f 91       	pop	r16
     c44:	ff 90       	pop	r15
     c46:	ef 90       	pop	r14
     c48:	08 95       	ret

00000c4a <xQueueReceive>:
     c4a:	9f 92       	push	r9
     c4c:	af 92       	push	r10
     c4e:	bf 92       	push	r11
     c50:	cf 92       	push	r12
     c52:	df 92       	push	r13
     c54:	ef 92       	push	r14
     c56:	ff 92       	push	r15
     c58:	0f 93       	push	r16
     c5a:	1f 93       	push	r17
     c5c:	cf 93       	push	r28
     c5e:	df 93       	push	r29
     c60:	00 d0       	rcall	.+0      	; 0xc62 <xQueueReceive+0x18>
     c62:	1f 92       	push	r1
     c64:	1f 92       	push	r1
     c66:	cd b7       	in	r28, 0x3d	; 61
     c68:	de b7       	in	r29, 0x3e	; 62
     c6a:	8c 01       	movw	r16, r24
     c6c:	5b 01       	movw	r10, r22
     c6e:	5d 83       	std	Y+5, r21	; 0x05
     c70:	4c 83       	std	Y+4, r20	; 0x04
     c72:	e1 2c       	mov	r14, r1
     c74:	99 24       	eor	r9, r9
     c76:	93 94       	inc	r9
     c78:	6c 01       	movw	r12, r24
     c7a:	81 e1       	ldi	r24, 0x11	; 17
     c7c:	c8 0e       	add	r12, r24
     c7e:	d1 1c       	adc	r13, r1
     c80:	0f b6       	in	r0, 0x3f	; 63
     c82:	f8 94       	cli
     c84:	0f 92       	push	r0
     c86:	f8 01       	movw	r30, r16
     c88:	f2 8c       	ldd	r15, Z+26	; 0x1a
     c8a:	ff 20       	and	r15, r15
     c8c:	91 f0       	breq	.+36     	; 0xcb2 <xQueueReceive+0x68>
     c8e:	b5 01       	movw	r22, r10
     c90:	c8 01       	movw	r24, r16
     c92:	26 de       	rcall	.-948    	; 0x8e0 <prvCopyDataFromQueue>
     c94:	fa 94       	dec	r15
     c96:	f8 01       	movw	r30, r16
     c98:	f2 8e       	std	Z+26, r15	; 0x1a
     c9a:	80 85       	ldd	r24, Z+8	; 0x08
     c9c:	88 23       	and	r24, r24
     c9e:	29 f0       	breq	.+10     	; 0xcaa <xQueueReceive+0x60>
     ca0:	c8 01       	movw	r24, r16
     ca2:	08 96       	adiw	r24, 0x08	; 8
     ca4:	3d d4       	rcall	.+2170   	; 0x1520 <xTaskRemoveFromEventList>
     ca6:	81 11       	cpse	r24, r1
     ca8:	ed dc       	rcall	.-1574   	; 0x684 <vPortYield>
     caa:	0f 90       	pop	r0
     cac:	0f be       	out	0x3f, r0	; 63
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	44 c0       	rjmp	.+136    	; 0xd3a <xQueueReceive+0xf0>
     cb2:	8c 81       	ldd	r24, Y+4	; 0x04
     cb4:	9d 81       	ldd	r25, Y+5	; 0x05
     cb6:	89 2b       	or	r24, r25
     cb8:	21 f4       	brne	.+8      	; 0xcc2 <xQueueReceive+0x78>
     cba:	0f 90       	pop	r0
     cbc:	0f be       	out	0x3f, r0	; 63
     cbe:	80 e0       	ldi	r24, 0x00	; 0
     cc0:	3c c0       	rjmp	.+120    	; 0xd3a <xQueueReceive+0xf0>
     cc2:	e1 10       	cpse	r14, r1
     cc4:	04 c0       	rjmp	.+8      	; 0xcce <xQueueReceive+0x84>
     cc6:	ce 01       	movw	r24, r28
     cc8:	01 96       	adiw	r24, 0x01	; 1
     cca:	72 d4       	rcall	.+2276   	; 0x15b0 <vTaskInternalSetTimeOutState>
     ccc:	e9 2c       	mov	r14, r9
     cce:	0f 90       	pop	r0
     cd0:	0f be       	out	0x3f, r0	; 63
     cd2:	10 d2       	rcall	.+1056   	; 0x10f4 <vTaskSuspendAll>
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	0f 92       	push	r0
     cda:	f8 01       	movw	r30, r16
     cdc:	85 8d       	ldd	r24, Z+29	; 0x1d
     cde:	8f 3f       	cpi	r24, 0xFF	; 255
     ce0:	09 f4       	brne	.+2      	; 0xce4 <xQueueReceive+0x9a>
     ce2:	15 8e       	std	Z+29, r1	; 0x1d
     ce4:	f8 01       	movw	r30, r16
     ce6:	86 8d       	ldd	r24, Z+30	; 0x1e
     ce8:	8f 3f       	cpi	r24, 0xFF	; 255
     cea:	09 f4       	brne	.+2      	; 0xcee <xQueueReceive+0xa4>
     cec:	16 8e       	std	Z+30, r1	; 0x1e
     cee:	0f 90       	pop	r0
     cf0:	0f be       	out	0x3f, r0	; 63
     cf2:	be 01       	movw	r22, r28
     cf4:	6c 5f       	subi	r22, 0xFC	; 252
     cf6:	7f 4f       	sbci	r23, 0xFF	; 255
     cf8:	ce 01       	movw	r24, r28
     cfa:	01 96       	adiw	r24, 0x01	; 1
     cfc:	64 d4       	rcall	.+2248   	; 0x15c6 <xTaskCheckForTimeOut>
     cfe:	81 11       	cpse	r24, r1
     d00:	13 c0       	rjmp	.+38     	; 0xd28 <xQueueReceive+0xde>
     d02:	c8 01       	movw	r24, r16
     d04:	84 dd       	rcall	.-1272   	; 0x80e <prvIsQueueEmpty>
     d06:	88 23       	and	r24, r24
     d08:	59 f0       	breq	.+22     	; 0xd20 <xQueueReceive+0xd6>
     d0a:	6c 81       	ldd	r22, Y+4	; 0x04
     d0c:	7d 81       	ldd	r23, Y+5	; 0x05
     d0e:	c6 01       	movw	r24, r12
     d10:	de d3       	rcall	.+1980   	; 0x14ce <vTaskPlaceOnEventList>
     d12:	c8 01       	movw	r24, r16
     d14:	ff dd       	rcall	.-1026   	; 0x914 <prvUnlockQueue>
     d16:	b5 d2       	rcall	.+1386   	; 0x1282 <xTaskResumeAll>
     d18:	81 11       	cpse	r24, r1
     d1a:	b2 cf       	rjmp	.-156    	; 0xc80 <xQueueReceive+0x36>
     d1c:	b3 dc       	rcall	.-1690   	; 0x684 <vPortYield>
     d1e:	b0 cf       	rjmp	.-160    	; 0xc80 <xQueueReceive+0x36>
     d20:	c8 01       	movw	r24, r16
     d22:	f8 dd       	rcall	.-1040   	; 0x914 <prvUnlockQueue>
     d24:	ae d2       	rcall	.+1372   	; 0x1282 <xTaskResumeAll>
     d26:	ac cf       	rjmp	.-168    	; 0xc80 <xQueueReceive+0x36>
     d28:	c8 01       	movw	r24, r16
     d2a:	f4 dd       	rcall	.-1048   	; 0x914 <prvUnlockQueue>
     d2c:	aa d2       	rcall	.+1364   	; 0x1282 <xTaskResumeAll>
     d2e:	c8 01       	movw	r24, r16
     d30:	6e dd       	rcall	.-1316   	; 0x80e <prvIsQueueEmpty>
     d32:	88 23       	and	r24, r24
     d34:	09 f4       	brne	.+2      	; 0xd38 <xQueueReceive+0xee>
     d36:	a4 cf       	rjmp	.-184    	; 0xc80 <xQueueReceive+0x36>
     d38:	80 e0       	ldi	r24, 0x00	; 0
     d3a:	0f 90       	pop	r0
     d3c:	0f 90       	pop	r0
     d3e:	0f 90       	pop	r0
     d40:	0f 90       	pop	r0
     d42:	0f 90       	pop	r0
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	ff 90       	pop	r15
     d4e:	ef 90       	pop	r14
     d50:	df 90       	pop	r13
     d52:	cf 90       	pop	r12
     d54:	bf 90       	pop	r11
     d56:	af 90       	pop	r10
     d58:	9f 90       	pop	r9
     d5a:	08 95       	ret

00000d5c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
     d5c:	cf 93       	push	r28
     d5e:	df 93       	push	r29
     d60:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
     d62:	0f b6       	in	r0, 0x3f	; 63
     d64:	f8 94       	cli
     d66:	0f 92       	push	r0
     d68:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d6a:	8f 3f       	cpi	r24, 0xFF	; 255
     d6c:	09 f4       	brne	.+2      	; 0xd70 <vQueueWaitForMessageRestricted+0x14>
     d6e:	1d 8e       	std	Y+29, r1	; 0x1d
     d70:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d72:	8f 3f       	cpi	r24, 0xFF	; 255
     d74:	09 f4       	brne	.+2      	; 0xd78 <vQueueWaitForMessageRestricted+0x1c>
     d76:	1e 8e       	std	Y+30, r1	; 0x1e
     d78:	0f 90       	pop	r0
     d7a:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     d7c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d7e:	81 11       	cpse	r24, r1
     d80:	03 c0       	rjmp	.+6      	; 0xd88 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     d82:	ce 01       	movw	r24, r28
     d84:	41 96       	adiw	r24, 0x11	; 17
     d86:	b4 d3       	rcall	.+1896   	; 0x14f0 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
     d88:	ce 01       	movw	r24, r28
     d8a:	c4 dd       	rcall	.-1144   	; 0x914 <prvUnlockQueue>
    }
     d8c:	df 91       	pop	r29
     d8e:	cf 91       	pop	r28
     d90:	08 95       	ret

00000d92 <prvResetNextTaskUnblockTime>:
     d92:	e0 91 68 02 	lds	r30, 0x0268	; 0x800268 <pxDelayedTaskList>
     d96:	f0 91 69 02 	lds	r31, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
     d9a:	80 81       	ld	r24, Z
     d9c:	81 11       	cpse	r24, r1
     d9e:	07 c0       	rjmp	.+14     	; 0xdae <prvResetNextTaskUnblockTime+0x1c>
     da0:	8f ef       	ldi	r24, 0xFF	; 255
     da2:	9f ef       	ldi	r25, 0xFF	; 255
     da4:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
     da8:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
     dac:	08 95       	ret
     dae:	e0 91 68 02 	lds	r30, 0x0268	; 0x800268 <pxDelayedTaskList>
     db2:	f0 91 69 02 	lds	r31, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
     db6:	05 80       	ldd	r0, Z+5	; 0x05
     db8:	f6 81       	ldd	r31, Z+6	; 0x06
     dba:	e0 2d       	mov	r30, r0
     dbc:	06 80       	ldd	r0, Z+6	; 0x06
     dbe:	f7 81       	ldd	r31, Z+7	; 0x07
     dc0:	e0 2d       	mov	r30, r0
     dc2:	82 81       	ldd	r24, Z+2	; 0x02
     dc4:	93 81       	ldd	r25, Z+3	; 0x03
     dc6:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
     dca:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
     dce:	08 95       	ret

00000dd0 <prvAddCurrentTaskToDelayedList>:
     dd0:	ff 92       	push	r15
     dd2:	0f 93       	push	r16
     dd4:	1f 93       	push	r17
     dd6:	cf 93       	push	r28
     dd8:	df 93       	push	r29
     dda:	ec 01       	movw	r28, r24
     ddc:	f6 2e       	mov	r15, r22
     dde:	00 91 47 02 	lds	r16, 0x0247	; 0x800247 <xTickCount>
     de2:	10 91 48 02 	lds	r17, 0x0248	; 0x800248 <xTickCount+0x1>
     de6:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     dea:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     dee:	02 96       	adiw	r24, 0x02	; 2
     df0:	74 db       	rcall	.-2328   	; 0x4da <uxListRemove>
     df2:	cf 3f       	cpi	r28, 0xFF	; 255
     df4:	8f ef       	ldi	r24, 0xFF	; 255
     df6:	d8 07       	cpc	r29, r24
     df8:	61 f4       	brne	.+24     	; 0xe12 <prvAddCurrentTaskToDelayedList+0x42>
     dfa:	ff 20       	and	r15, r15
     dfc:	51 f0       	breq	.+20     	; 0xe12 <prvAddCurrentTaskToDelayedList+0x42>
     dfe:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     e02:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     e06:	6e 5f       	subi	r22, 0xFE	; 254
     e08:	7f 4f       	sbci	r23, 0xFF	; 255
     e0a:	8a e4       	ldi	r24, 0x4A	; 74
     e0c:	92 e0       	ldi	r25, 0x02	; 2
     e0e:	13 db       	rcall	.-2522   	; 0x436 <vListInsertEnd>
     e10:	2d c0       	rjmp	.+90     	; 0xe6c <prvAddCurrentTaskToDelayedList+0x9c>
     e12:	c0 0f       	add	r28, r16
     e14:	d1 1f       	adc	r29, r17
     e16:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     e1a:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     e1e:	d3 83       	std	Z+3, r29	; 0x03
     e20:	c2 83       	std	Z+2, r28	; 0x02
     e22:	c0 17       	cp	r28, r16
     e24:	d1 07       	cpc	r29, r17
     e26:	60 f4       	brcc	.+24     	; 0xe40 <prvAddCurrentTaskToDelayedList+0x70>
     e28:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     e2c:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     e30:	80 91 66 02 	lds	r24, 0x0266	; 0x800266 <pxOverflowDelayedTaskList>
     e34:	90 91 67 02 	lds	r25, 0x0267	; 0x800267 <pxOverflowDelayedTaskList+0x1>
     e38:	6e 5f       	subi	r22, 0xFE	; 254
     e3a:	7f 4f       	sbci	r23, 0xFF	; 255
     e3c:	1d db       	rcall	.-2502   	; 0x478 <vListInsert>
     e3e:	16 c0       	rjmp	.+44     	; 0xe6c <prvAddCurrentTaskToDelayedList+0x9c>
     e40:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     e44:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     e48:	80 91 68 02 	lds	r24, 0x0268	; 0x800268 <pxDelayedTaskList>
     e4c:	90 91 69 02 	lds	r25, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
     e50:	6e 5f       	subi	r22, 0xFE	; 254
     e52:	7f 4f       	sbci	r23, 0xFF	; 255
     e54:	11 db       	rcall	.-2526   	; 0x478 <vListInsert>
     e56:	80 91 3f 02 	lds	r24, 0x023F	; 0x80023f <xNextTaskUnblockTime>
     e5a:	90 91 40 02 	lds	r25, 0x0240	; 0x800240 <xNextTaskUnblockTime+0x1>
     e5e:	c8 17       	cp	r28, r24
     e60:	d9 07       	cpc	r29, r25
     e62:	20 f4       	brcc	.+8      	; 0xe6c <prvAddCurrentTaskToDelayedList+0x9c>
     e64:	d0 93 40 02 	sts	0x0240, r29	; 0x800240 <xNextTaskUnblockTime+0x1>
     e68:	c0 93 3f 02 	sts	0x023F, r28	; 0x80023f <xNextTaskUnblockTime>
     e6c:	df 91       	pop	r29
     e6e:	cf 91       	pop	r28
     e70:	1f 91       	pop	r17
     e72:	0f 91       	pop	r16
     e74:	ff 90       	pop	r15
     e76:	08 95       	ret

00000e78 <xTaskCreate>:
     e78:	4f 92       	push	r4
     e7a:	5f 92       	push	r5
     e7c:	6f 92       	push	r6
     e7e:	7f 92       	push	r7
     e80:	8f 92       	push	r8
     e82:	9f 92       	push	r9
     e84:	af 92       	push	r10
     e86:	bf 92       	push	r11
     e88:	cf 92       	push	r12
     e8a:	df 92       	push	r13
     e8c:	ef 92       	push	r14
     e8e:	ff 92       	push	r15
     e90:	0f 93       	push	r16
     e92:	cf 93       	push	r28
     e94:	df 93       	push	r29
     e96:	4c 01       	movw	r8, r24
     e98:	6b 01       	movw	r12, r22
     e9a:	5a 01       	movw	r10, r20
     e9c:	29 01       	movw	r4, r18
     e9e:	ca 01       	movw	r24, r20
     ea0:	9a da       	rcall	.-2764   	; 0x3d6 <pvPortMalloc>
     ea2:	3c 01       	movw	r6, r24
     ea4:	89 2b       	or	r24, r25
     ea6:	09 f4       	brne	.+2      	; 0xeaa <xTaskCreate+0x32>
     ea8:	e3 c0       	rjmp	.+454    	; 0x1070 <xTaskCreate+0x1f8>
     eaa:	8c e2       	ldi	r24, 0x2C	; 44
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	93 da       	rcall	.-2778   	; 0x3d6 <pvPortMalloc>
     eb0:	ec 01       	movw	r28, r24
     eb2:	89 2b       	or	r24, r25
     eb4:	91 f0       	breq	.+36     	; 0xeda <xTaskCreate+0x62>
     eb6:	78 8e       	std	Y+24, r7	; 0x18
     eb8:	6f 8a       	std	Y+23, r6	; 0x17
     eba:	a5 01       	movw	r20, r10
     ebc:	65 ea       	ldi	r22, 0xA5	; 165
     ebe:	70 e0       	ldi	r23, 0x00	; 0
     ec0:	c3 01       	movw	r24, r6
     ec2:	e0 d6       	rcall	.+3520   	; 0x1c84 <memset>
     ec4:	81 e0       	ldi	r24, 0x01	; 1
     ec6:	a8 1a       	sub	r10, r24
     ec8:	b1 08       	sbc	r11, r1
     eca:	8f 89       	ldd	r24, Y+23	; 0x17
     ecc:	98 8d       	ldd	r25, Y+24	; 0x18
     ece:	a8 0e       	add	r10, r24
     ed0:	b9 1e       	adc	r11, r25
     ed2:	c1 14       	cp	r12, r1
     ed4:	d1 04       	cpc	r13, r1
     ed6:	21 f4       	brne	.+8      	; 0xee0 <xTaskCreate+0x68>
     ed8:	1f c0       	rjmp	.+62     	; 0xf18 <xTaskCreate+0xa0>
     eda:	c3 01       	movw	r24, r6
     edc:	8d da       	rcall	.-2790   	; 0x3f8 <vPortFree>
     ede:	c8 c0       	rjmp	.+400    	; 0x1070 <xTaskCreate+0x1f8>
     ee0:	d6 01       	movw	r26, r12
     ee2:	8c 91       	ld	r24, X
     ee4:	89 8f       	std	Y+25, r24	; 0x19
     ee6:	8c 91       	ld	r24, X
     ee8:	88 23       	and	r24, r24
     eea:	a1 f0       	breq	.+40     	; 0xf14 <xTaskCreate+0x9c>
     eec:	ae 01       	movw	r20, r28
     eee:	46 5e       	subi	r20, 0xE6	; 230
     ef0:	5f 4f       	sbci	r21, 0xFF	; 255
     ef2:	f6 01       	movw	r30, r12
     ef4:	31 96       	adiw	r30, 0x01	; 1
     ef6:	b8 e0       	ldi	r27, 0x08	; 8
     ef8:	cb 0e       	add	r12, r27
     efa:	d1 1c       	adc	r13, r1
     efc:	cf 01       	movw	r24, r30
     efe:	21 91       	ld	r18, Z+
     f00:	da 01       	movw	r26, r20
     f02:	2d 93       	st	X+, r18
     f04:	ad 01       	movw	r20, r26
     f06:	dc 01       	movw	r26, r24
     f08:	8c 91       	ld	r24, X
     f0a:	88 23       	and	r24, r24
     f0c:	19 f0       	breq	.+6      	; 0xf14 <xTaskCreate+0x9c>
     f0e:	ec 15       	cp	r30, r12
     f10:	fd 05       	cpc	r31, r13
     f12:	a1 f7       	brne	.-24     	; 0xefc <xTaskCreate+0x84>
     f14:	18 a2       	std	Y+32, r1	; 0x20
     f16:	01 c0       	rjmp	.+2      	; 0xf1a <xTaskCreate+0xa2>
     f18:	19 8e       	std	Y+25, r1	; 0x19
     f1a:	04 30       	cpi	r16, 0x04	; 4
     f1c:	08 f0       	brcs	.+2      	; 0xf20 <xTaskCreate+0xa8>
     f1e:	03 e0       	ldi	r16, 0x03	; 3
     f20:	0e 8b       	std	Y+22, r16	; 0x16
     f22:	0b a3       	std	Y+35, r16	; 0x23
     f24:	1c a2       	std	Y+36, r1	; 0x24
     f26:	6e 01       	movw	r12, r28
     f28:	b2 e0       	ldi	r27, 0x02	; 2
     f2a:	cb 0e       	add	r12, r27
     f2c:	d1 1c       	adc	r13, r1
     f2e:	c6 01       	movw	r24, r12
     f30:	7e da       	rcall	.-2820   	; 0x42e <vListInitialiseItem>
     f32:	ce 01       	movw	r24, r28
     f34:	0c 96       	adiw	r24, 0x0c	; 12
     f36:	7b da       	rcall	.-2826   	; 0x42e <vListInitialiseItem>
     f38:	d9 87       	std	Y+9, r29	; 0x09
     f3a:	c8 87       	std	Y+8, r28	; 0x08
     f3c:	84 e0       	ldi	r24, 0x04	; 4
     f3e:	90 e0       	ldi	r25, 0x00	; 0
     f40:	80 1b       	sub	r24, r16
     f42:	91 09       	sbc	r25, r1
     f44:	9d 87       	std	Y+13, r25	; 0x0d
     f46:	8c 87       	std	Y+12, r24	; 0x0c
     f48:	db 8b       	std	Y+19, r29	; 0x13
     f4a:	ca 8b       	std	Y+18, r28	; 0x12
     f4c:	1e a2       	std	Y+38, r1	; 0x26
     f4e:	1d a2       	std	Y+37, r1	; 0x25
     f50:	1f a2       	std	Y+39, r1	; 0x27
     f52:	18 a6       	std	Y+40, r1	; 0x28
     f54:	19 a6       	std	Y+41, r1	; 0x29
     f56:	1a a6       	std	Y+42, r1	; 0x2a
     f58:	1b a6       	std	Y+43, r1	; 0x2b
     f5a:	a2 01       	movw	r20, r4
     f5c:	b4 01       	movw	r22, r8
     f5e:	c5 01       	movw	r24, r10
     f60:	e3 da       	rcall	.-2618   	; 0x528 <pxPortInitialiseStack>
     f62:	99 83       	std	Y+1, r25	; 0x01
     f64:	88 83       	st	Y, r24
     f66:	e1 14       	cp	r14, r1
     f68:	f1 04       	cpc	r15, r1
     f6a:	19 f0       	breq	.+6      	; 0xf72 <xTaskCreate+0xfa>
     f6c:	f7 01       	movw	r30, r14
     f6e:	d1 83       	std	Z+1, r29	; 0x01
     f70:	c0 83       	st	Z, r28
     f72:	0f b6       	in	r0, 0x3f	; 63
     f74:	f8 94       	cli
     f76:	0f 92       	push	r0
     f78:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
     f7c:	8f 5f       	subi	r24, 0xFF	; 255
     f7e:	80 93 49 02 	sts	0x0249, r24	; 0x800249 <uxCurrentNumberOfTasks>
     f82:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     f86:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     f8a:	89 2b       	or	r24, r25
     f8c:	89 f5       	brne	.+98     	; 0xff0 <xTaskCreate+0x178>
     f8e:	d0 93 a1 02 	sts	0x02A1, r29	; 0x8002a1 <pxCurrentTCB+0x1>
     f92:	c0 93 a0 02 	sts	0x02A0, r28	; 0x8002a0 <pxCurrentTCB>
     f96:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
     f9a:	81 30       	cpi	r24, 0x01	; 1
     f9c:	09 f0       	breq	.+2      	; 0xfa0 <xTaskCreate+0x128>
     f9e:	38 c0       	rjmp	.+112    	; 0x1010 <xTaskCreate+0x198>
     fa0:	8c e7       	ldi	r24, 0x7C	; 124
     fa2:	92 e0       	ldi	r25, 0x02	; 2
     fa4:	36 da       	rcall	.-2964   	; 0x412 <vListInitialise>
     fa6:	85 e8       	ldi	r24, 0x85	; 133
     fa8:	92 e0       	ldi	r25, 0x02	; 2
     faa:	33 da       	rcall	.-2970   	; 0x412 <vListInitialise>
     fac:	8e e8       	ldi	r24, 0x8E	; 142
     fae:	92 e0       	ldi	r25, 0x02	; 2
     fb0:	30 da       	rcall	.-2976   	; 0x412 <vListInitialise>
     fb2:	87 e9       	ldi	r24, 0x97	; 151
     fb4:	92 e0       	ldi	r25, 0x02	; 2
     fb6:	2d da       	rcall	.-2982   	; 0x412 <vListInitialise>
     fb8:	83 e7       	ldi	r24, 0x73	; 115
     fba:	92 e0       	ldi	r25, 0x02	; 2
     fbc:	2a da       	rcall	.-2988   	; 0x412 <vListInitialise>
     fbe:	8a e6       	ldi	r24, 0x6A	; 106
     fc0:	92 e0       	ldi	r25, 0x02	; 2
     fc2:	27 da       	rcall	.-2994   	; 0x412 <vListInitialise>
     fc4:	8d e5       	ldi	r24, 0x5D	; 93
     fc6:	92 e0       	ldi	r25, 0x02	; 2
     fc8:	24 da       	rcall	.-3000   	; 0x412 <vListInitialise>
     fca:	84 e5       	ldi	r24, 0x54	; 84
     fcc:	92 e0       	ldi	r25, 0x02	; 2
     fce:	21 da       	rcall	.-3006   	; 0x412 <vListInitialise>
     fd0:	8a e4       	ldi	r24, 0x4A	; 74
     fd2:	92 e0       	ldi	r25, 0x02	; 2
     fd4:	1e da       	rcall	.-3012   	; 0x412 <vListInitialise>
     fd6:	83 e7       	ldi	r24, 0x73	; 115
     fd8:	92 e0       	ldi	r25, 0x02	; 2
     fda:	90 93 69 02 	sts	0x0269, r25	; 0x800269 <pxDelayedTaskList+0x1>
     fde:	80 93 68 02 	sts	0x0268, r24	; 0x800268 <pxDelayedTaskList>
     fe2:	8a e6       	ldi	r24, 0x6A	; 106
     fe4:	92 e0       	ldi	r25, 0x02	; 2
     fe6:	90 93 67 02 	sts	0x0267, r25	; 0x800267 <pxOverflowDelayedTaskList+0x1>
     fea:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <pxOverflowDelayedTaskList>
     fee:	10 c0       	rjmp	.+32     	; 0x1010 <xTaskCreate+0x198>
     ff0:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <xSchedulerRunning>
     ff4:	81 11       	cpse	r24, r1
     ff6:	0c c0       	rjmp	.+24     	; 0x1010 <xTaskCreate+0x198>
     ff8:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     ffc:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1000:	96 89       	ldd	r25, Z+22	; 0x16
    1002:	8e 89       	ldd	r24, Y+22	; 0x16
    1004:	89 17       	cp	r24, r25
    1006:	20 f0       	brcs	.+8      	; 0x1010 <xTaskCreate+0x198>
    1008:	d0 93 a1 02 	sts	0x02A1, r29	; 0x8002a1 <pxCurrentTCB+0x1>
    100c:	c0 93 a0 02 	sts	0x02A0, r28	; 0x8002a0 <pxCurrentTCB>
    1010:	80 91 41 02 	lds	r24, 0x0241	; 0x800241 <uxTaskNumber>
    1014:	8f 5f       	subi	r24, 0xFF	; 255
    1016:	80 93 41 02 	sts	0x0241, r24	; 0x800241 <uxTaskNumber>
    101a:	89 a3       	std	Y+33, r24	; 0x21
    101c:	8e 89       	ldd	r24, Y+22	; 0x16
    101e:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    1022:	98 17       	cp	r25, r24
    1024:	10 f4       	brcc	.+4      	; 0x102a <xTaskCreate+0x1b2>
    1026:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	9c 01       	movw	r18, r24
    102e:	22 0f       	add	r18, r18
    1030:	33 1f       	adc	r19, r19
    1032:	22 0f       	add	r18, r18
    1034:	33 1f       	adc	r19, r19
    1036:	22 0f       	add	r18, r18
    1038:	33 1f       	adc	r19, r19
    103a:	82 0f       	add	r24, r18
    103c:	93 1f       	adc	r25, r19
    103e:	b6 01       	movw	r22, r12
    1040:	84 58       	subi	r24, 0x84	; 132
    1042:	9d 4f       	sbci	r25, 0xFD	; 253
    1044:	f8 d9       	rcall	.-3088   	; 0x436 <vListInsertEnd>
    1046:	0f 90       	pop	r0
    1048:	0f be       	out	0x3f, r0	; 63
    104a:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <xSchedulerRunning>
    104e:	88 23       	and	r24, r24
    1050:	59 f0       	breq	.+22     	; 0x1068 <xTaskCreate+0x1f0>
    1052:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1056:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    105a:	96 89       	ldd	r25, Z+22	; 0x16
    105c:	8e 89       	ldd	r24, Y+22	; 0x16
    105e:	98 17       	cp	r25, r24
    1060:	28 f4       	brcc	.+10     	; 0x106c <xTaskCreate+0x1f4>
    1062:	10 db       	rcall	.-2528   	; 0x684 <vPortYield>
    1064:	81 e0       	ldi	r24, 0x01	; 1
    1066:	05 c0       	rjmp	.+10     	; 0x1072 <xTaskCreate+0x1fa>
    1068:	81 e0       	ldi	r24, 0x01	; 1
    106a:	03 c0       	rjmp	.+6      	; 0x1072 <xTaskCreate+0x1fa>
    106c:	81 e0       	ldi	r24, 0x01	; 1
    106e:	01 c0       	rjmp	.+2      	; 0x1072 <xTaskCreate+0x1fa>
    1070:	8f ef       	ldi	r24, 0xFF	; 255
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	0f 91       	pop	r16
    1078:	ff 90       	pop	r15
    107a:	ef 90       	pop	r14
    107c:	df 90       	pop	r13
    107e:	cf 90       	pop	r12
    1080:	bf 90       	pop	r11
    1082:	af 90       	pop	r10
    1084:	9f 90       	pop	r9
    1086:	8f 90       	pop	r8
    1088:	7f 90       	pop	r7
    108a:	6f 90       	pop	r6
    108c:	5f 90       	pop	r5
    108e:	4f 90       	pop	r4
    1090:	08 95       	ret

00001092 <vTaskStartScheduler>:
    1092:	ef 92       	push	r14
    1094:	ff 92       	push	r15
    1096:	0f 93       	push	r16
    1098:	0f 2e       	mov	r0, r31
    109a:	fd e3       	ldi	r31, 0x3D	; 61
    109c:	ef 2e       	mov	r14, r31
    109e:	f2 e0       	ldi	r31, 0x02	; 2
    10a0:	ff 2e       	mov	r15, r31
    10a2:	f0 2d       	mov	r31, r0
    10a4:	00 e0       	ldi	r16, 0x00	; 0
    10a6:	20 e0       	ldi	r18, 0x00	; 0
    10a8:	30 e0       	ldi	r19, 0x00	; 0
    10aa:	40 ec       	ldi	r20, 0xC0	; 192
    10ac:	50 e0       	ldi	r21, 0x00	; 0
    10ae:	66 e0       	ldi	r22, 0x06	; 6
    10b0:	72 e0       	ldi	r23, 0x02	; 2
    10b2:	8c e7       	ldi	r24, 0x7C	; 124
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	e0 de       	rcall	.-576    	; 0xe78 <xTaskCreate>
    10b8:	81 30       	cpi	r24, 0x01	; 1
    10ba:	c1 f4       	brne	.+48     	; 0x10ec <vTaskStartScheduler+0x5a>
    10bc:	62 d3       	rcall	.+1732   	; 0x1782 <xTimerCreateTimerTask>
    10be:	81 30       	cpi	r24, 0x01	; 1
    10c0:	a9 f4       	brne	.+42     	; 0x10ec <vTaskStartScheduler+0x5a>
    10c2:	f8 94       	cli
    10c4:	8f ef       	ldi	r24, 0xFF	; 255
    10c6:	9f ef       	ldi	r25, 0xFF	; 255
    10c8:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
    10cc:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
    10d0:	81 e0       	ldi	r24, 0x01	; 1
    10d2:	80 93 45 02 	sts	0x0245, r24	; 0x800245 <xSchedulerRunning>
    10d6:	10 92 48 02 	sts	0x0248, r1	; 0x800248 <xTickCount+0x1>
    10da:	10 92 47 02 	sts	0x0247, r1	; 0x800247 <xTickCount>
    10de:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    10e2:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    10e6:	85 a1       	ldd	r24, Z+37	; 0x25
    10e8:	66 d9       	rcall	.-3380   	; 0x3b6 <task_switch_in>
    10ea:	90 da       	rcall	.-2784   	; 0x60c <xPortStartScheduler>
    10ec:	0f 91       	pop	r16
    10ee:	ff 90       	pop	r15
    10f0:	ef 90       	pop	r14
    10f2:	08 95       	ret

000010f4 <vTaskSuspendAll>:
    10f4:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <__data_end>
    10f8:	8f 5f       	subi	r24, 0xFF	; 255
    10fa:	80 93 3c 02 	sts	0x023C, r24	; 0x80023c <__data_end>
    10fe:	08 95       	ret

00001100 <xTaskGetTickCount>:
    1100:	0f b6       	in	r0, 0x3f	; 63
    1102:	f8 94       	cli
    1104:	0f 92       	push	r0
    1106:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <xTickCount>
    110a:	90 91 48 02 	lds	r25, 0x0248	; 0x800248 <xTickCount+0x1>
    110e:	0f 90       	pop	r0
    1110:	0f be       	out	0x3f, r0	; 63
    1112:	08 95       	ret

00001114 <xTaskIncrementTick>:
    1114:	cf 92       	push	r12
    1116:	df 92       	push	r13
    1118:	ef 92       	push	r14
    111a:	ff 92       	push	r15
    111c:	0f 93       	push	r16
    111e:	1f 93       	push	r17
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <__data_end>
    1128:	81 11       	cpse	r24, r1
    112a:	95 c0       	rjmp	.+298    	; 0x1256 <xTaskIncrementTick+0x142>
    112c:	e0 90 47 02 	lds	r14, 0x0247	; 0x800247 <xTickCount>
    1130:	f0 90 48 02 	lds	r15, 0x0248	; 0x800248 <xTickCount+0x1>
    1134:	8f ef       	ldi	r24, 0xFF	; 255
    1136:	e8 1a       	sub	r14, r24
    1138:	f8 0a       	sbc	r15, r24
    113a:	f0 92 48 02 	sts	0x0248, r15	; 0x800248 <xTickCount+0x1>
    113e:	e0 92 47 02 	sts	0x0247, r14	; 0x800247 <xTickCount>
    1142:	e1 14       	cp	r14, r1
    1144:	f1 04       	cpc	r15, r1
    1146:	b1 f4       	brne	.+44     	; 0x1174 <xTaskIncrementTick+0x60>
    1148:	80 91 68 02 	lds	r24, 0x0268	; 0x800268 <pxDelayedTaskList>
    114c:	90 91 69 02 	lds	r25, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    1150:	20 91 66 02 	lds	r18, 0x0266	; 0x800266 <pxOverflowDelayedTaskList>
    1154:	30 91 67 02 	lds	r19, 0x0267	; 0x800267 <pxOverflowDelayedTaskList+0x1>
    1158:	30 93 69 02 	sts	0x0269, r19	; 0x800269 <pxDelayedTaskList+0x1>
    115c:	20 93 68 02 	sts	0x0268, r18	; 0x800268 <pxDelayedTaskList>
    1160:	90 93 67 02 	sts	0x0267, r25	; 0x800267 <pxOverflowDelayedTaskList+0x1>
    1164:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <pxOverflowDelayedTaskList>
    1168:	80 91 42 02 	lds	r24, 0x0242	; 0x800242 <xNumOfOverflows>
    116c:	8f 5f       	subi	r24, 0xFF	; 255
    116e:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <xNumOfOverflows>
    1172:	0f de       	rcall	.-994    	; 0xd92 <prvResetNextTaskUnblockTime>
    1174:	80 91 3f 02 	lds	r24, 0x023F	; 0x80023f <xNextTaskUnblockTime>
    1178:	90 91 40 02 	lds	r25, 0x0240	; 0x800240 <xNextTaskUnblockTime+0x1>
    117c:	e8 16       	cp	r14, r24
    117e:	f9 06       	cpc	r15, r25
    1180:	10 f4       	brcc	.+4      	; 0x1186 <xTaskIncrementTick+0x72>
    1182:	d1 2c       	mov	r13, r1
    1184:	50 c0       	rjmp	.+160    	; 0x1226 <xTaskIncrementTick+0x112>
    1186:	d1 2c       	mov	r13, r1
    1188:	cc 24       	eor	r12, r12
    118a:	c3 94       	inc	r12
    118c:	e0 91 68 02 	lds	r30, 0x0268	; 0x800268 <pxDelayedTaskList>
    1190:	f0 91 69 02 	lds	r31, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    1194:	80 81       	ld	r24, Z
    1196:	81 11       	cpse	r24, r1
    1198:	07 c0       	rjmp	.+14     	; 0x11a8 <xTaskIncrementTick+0x94>
    119a:	8f ef       	ldi	r24, 0xFF	; 255
    119c:	9f ef       	ldi	r25, 0xFF	; 255
    119e:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
    11a2:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
    11a6:	3f c0       	rjmp	.+126    	; 0x1226 <xTaskIncrementTick+0x112>
    11a8:	e0 91 68 02 	lds	r30, 0x0268	; 0x800268 <pxDelayedTaskList>
    11ac:	f0 91 69 02 	lds	r31, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    11b0:	05 80       	ldd	r0, Z+5	; 0x05
    11b2:	f6 81       	ldd	r31, Z+6	; 0x06
    11b4:	e0 2d       	mov	r30, r0
    11b6:	c6 81       	ldd	r28, Z+6	; 0x06
    11b8:	d7 81       	ldd	r29, Z+7	; 0x07
    11ba:	8a 81       	ldd	r24, Y+2	; 0x02
    11bc:	9b 81       	ldd	r25, Y+3	; 0x03
    11be:	e8 16       	cp	r14, r24
    11c0:	f9 06       	cpc	r15, r25
    11c2:	28 f4       	brcc	.+10     	; 0x11ce <xTaskIncrementTick+0xba>
    11c4:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
    11c8:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
    11cc:	2c c0       	rjmp	.+88     	; 0x1226 <xTaskIncrementTick+0x112>
    11ce:	8e 01       	movw	r16, r28
    11d0:	0e 5f       	subi	r16, 0xFE	; 254
    11d2:	1f 4f       	sbci	r17, 0xFF	; 255
    11d4:	c8 01       	movw	r24, r16
    11d6:	81 d9       	rcall	.-3326   	; 0x4da <uxListRemove>
    11d8:	8c 89       	ldd	r24, Y+20	; 0x14
    11da:	9d 89       	ldd	r25, Y+21	; 0x15
    11dc:	89 2b       	or	r24, r25
    11de:	19 f0       	breq	.+6      	; 0x11e6 <xTaskIncrementTick+0xd2>
    11e0:	ce 01       	movw	r24, r28
    11e2:	0c 96       	adiw	r24, 0x0c	; 12
    11e4:	7a d9       	rcall	.-3340   	; 0x4da <uxListRemove>
    11e6:	8e 89       	ldd	r24, Y+22	; 0x16
    11e8:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    11ec:	98 17       	cp	r25, r24
    11ee:	10 f4       	brcc	.+4      	; 0x11f4 <xTaskIncrementTick+0xe0>
    11f0:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	9c 01       	movw	r18, r24
    11f8:	22 0f       	add	r18, r18
    11fa:	33 1f       	adc	r19, r19
    11fc:	22 0f       	add	r18, r18
    11fe:	33 1f       	adc	r19, r19
    1200:	22 0f       	add	r18, r18
    1202:	33 1f       	adc	r19, r19
    1204:	82 0f       	add	r24, r18
    1206:	93 1f       	adc	r25, r19
    1208:	b8 01       	movw	r22, r16
    120a:	84 58       	subi	r24, 0x84	; 132
    120c:	9d 4f       	sbci	r25, 0xFD	; 253
    120e:	13 d9       	rcall	.-3546   	; 0x436 <vListInsertEnd>
    1210:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1214:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1218:	9e 89       	ldd	r25, Y+22	; 0x16
    121a:	86 89       	ldd	r24, Z+22	; 0x16
    121c:	98 17       	cp	r25, r24
    121e:	08 f4       	brcc	.+2      	; 0x1222 <xTaskIncrementTick+0x10e>
    1220:	b5 cf       	rjmp	.-150    	; 0x118c <xTaskIncrementTick+0x78>
    1222:	dc 2c       	mov	r13, r12
    1224:	b3 cf       	rjmp	.-154    	; 0x118c <xTaskIncrementTick+0x78>
    1226:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    122a:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    122e:	86 89       	ldd	r24, Z+22	; 0x16
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	fc 01       	movw	r30, r24
    1234:	ee 0f       	add	r30, r30
    1236:	ff 1f       	adc	r31, r31
    1238:	ee 0f       	add	r30, r30
    123a:	ff 1f       	adc	r31, r31
    123c:	ee 0f       	add	r30, r30
    123e:	ff 1f       	adc	r31, r31
    1240:	8e 0f       	add	r24, r30
    1242:	9f 1f       	adc	r25, r31
    1244:	fc 01       	movw	r30, r24
    1246:	e4 58       	subi	r30, 0x84	; 132
    1248:	fd 4f       	sbci	r31, 0xFD	; 253
    124a:	80 81       	ld	r24, Z
    124c:	82 30       	cpi	r24, 0x02	; 2
    124e:	48 f0       	brcs	.+18     	; 0x1262 <xTaskIncrementTick+0x14e>
    1250:	dd 24       	eor	r13, r13
    1252:	d3 94       	inc	r13
    1254:	06 c0       	rjmp	.+12     	; 0x1262 <xTaskIncrementTick+0x14e>
    1256:	80 91 44 02 	lds	r24, 0x0244	; 0x800244 <uxPendedTicks>
    125a:	8f 5f       	subi	r24, 0xFF	; 255
    125c:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <uxPendedTicks>
    1260:	d1 2c       	mov	r13, r1
    1262:	80 91 43 02 	lds	r24, 0x0243	; 0x800243 <xYieldPending>
    1266:	88 23       	and	r24, r24
    1268:	11 f0       	breq	.+4      	; 0x126e <xTaskIncrementTick+0x15a>
    126a:	dd 24       	eor	r13, r13
    126c:	d3 94       	inc	r13
    126e:	8d 2d       	mov	r24, r13
    1270:	df 91       	pop	r29
    1272:	cf 91       	pop	r28
    1274:	1f 91       	pop	r17
    1276:	0f 91       	pop	r16
    1278:	ff 90       	pop	r15
    127a:	ef 90       	pop	r14
    127c:	df 90       	pop	r13
    127e:	cf 90       	pop	r12
    1280:	08 95       	ret

00001282 <xTaskResumeAll>:
    1282:	df 92       	push	r13
    1284:	ef 92       	push	r14
    1286:	ff 92       	push	r15
    1288:	0f 93       	push	r16
    128a:	1f 93       	push	r17
    128c:	cf 93       	push	r28
    128e:	df 93       	push	r29
    1290:	0f b6       	in	r0, 0x3f	; 63
    1292:	f8 94       	cli
    1294:	0f 92       	push	r0
    1296:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <__data_end>
    129a:	81 50       	subi	r24, 0x01	; 1
    129c:	80 93 3c 02 	sts	0x023C, r24	; 0x80023c <__data_end>
    12a0:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <__data_end>
    12a4:	81 11       	cpse	r24, r1
    12a6:	59 c0       	rjmp	.+178    	; 0x135a <xTaskResumeAll+0xd8>
    12a8:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
    12ac:	81 11       	cpse	r24, r1
    12ae:	30 c0       	rjmp	.+96     	; 0x1310 <xTaskResumeAll+0x8e>
    12b0:	57 c0       	rjmp	.+174    	; 0x1360 <xTaskResumeAll+0xde>
    12b2:	d7 01       	movw	r26, r14
    12b4:	15 96       	adiw	r26, 0x05	; 5
    12b6:	ed 91       	ld	r30, X+
    12b8:	fc 91       	ld	r31, X
    12ba:	16 97       	sbiw	r26, 0x06	; 6
    12bc:	c6 81       	ldd	r28, Z+6	; 0x06
    12be:	d7 81       	ldd	r29, Z+7	; 0x07
    12c0:	ce 01       	movw	r24, r28
    12c2:	0c 96       	adiw	r24, 0x0c	; 12
    12c4:	0a d9       	rcall	.-3564   	; 0x4da <uxListRemove>
    12c6:	8e 01       	movw	r16, r28
    12c8:	0e 5f       	subi	r16, 0xFE	; 254
    12ca:	1f 4f       	sbci	r17, 0xFF	; 255
    12cc:	c8 01       	movw	r24, r16
    12ce:	05 d9       	rcall	.-3574   	; 0x4da <uxListRemove>
    12d0:	8e 89       	ldd	r24, Y+22	; 0x16
    12d2:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    12d6:	98 17       	cp	r25, r24
    12d8:	10 f4       	brcc	.+4      	; 0x12de <xTaskResumeAll+0x5c>
    12da:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	9c 01       	movw	r18, r24
    12e2:	22 0f       	add	r18, r18
    12e4:	33 1f       	adc	r19, r19
    12e6:	22 0f       	add	r18, r18
    12e8:	33 1f       	adc	r19, r19
    12ea:	22 0f       	add	r18, r18
    12ec:	33 1f       	adc	r19, r19
    12ee:	82 0f       	add	r24, r18
    12f0:	93 1f       	adc	r25, r19
    12f2:	b8 01       	movw	r22, r16
    12f4:	84 58       	subi	r24, 0x84	; 132
    12f6:	9d 4f       	sbci	r25, 0xFD	; 253
    12f8:	9e d8       	rcall	.-3780   	; 0x436 <vListInsertEnd>
    12fa:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    12fe:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1302:	9e 89       	ldd	r25, Y+22	; 0x16
    1304:	86 89       	ldd	r24, Z+22	; 0x16
    1306:	98 17       	cp	r25, r24
    1308:	68 f0       	brcs	.+26     	; 0x1324 <xTaskResumeAll+0xa2>
    130a:	d0 92 43 02 	sts	0x0243, r13	; 0x800243 <xYieldPending>
    130e:	0a c0       	rjmp	.+20     	; 0x1324 <xTaskResumeAll+0xa2>
    1310:	c0 e0       	ldi	r28, 0x00	; 0
    1312:	d0 e0       	ldi	r29, 0x00	; 0
    1314:	0f 2e       	mov	r0, r31
    1316:	fd e5       	ldi	r31, 0x5D	; 93
    1318:	ef 2e       	mov	r14, r31
    131a:	f2 e0       	ldi	r31, 0x02	; 2
    131c:	ff 2e       	mov	r15, r31
    131e:	f0 2d       	mov	r31, r0
    1320:	dd 24       	eor	r13, r13
    1322:	d3 94       	inc	r13
    1324:	f7 01       	movw	r30, r14
    1326:	80 81       	ld	r24, Z
    1328:	81 11       	cpse	r24, r1
    132a:	c3 cf       	rjmp	.-122    	; 0x12b2 <xTaskResumeAll+0x30>
    132c:	cd 2b       	or	r28, r29
    132e:	09 f0       	breq	.+2      	; 0x1332 <xTaskResumeAll+0xb0>
    1330:	30 dd       	rcall	.-1440   	; 0xd92 <prvResetNextTaskUnblockTime>
    1332:	c0 91 44 02 	lds	r28, 0x0244	; 0x800244 <uxPendedTicks>
    1336:	cc 23       	and	r28, r28
    1338:	49 f0       	breq	.+18     	; 0x134c <xTaskResumeAll+0xca>
    133a:	d1 e0       	ldi	r29, 0x01	; 1
    133c:	eb de       	rcall	.-554    	; 0x1114 <xTaskIncrementTick>
    133e:	81 11       	cpse	r24, r1
    1340:	d0 93 43 02 	sts	0x0243, r29	; 0x800243 <xYieldPending>
    1344:	c1 50       	subi	r28, 0x01	; 1
    1346:	d1 f7       	brne	.-12     	; 0x133c <xTaskResumeAll+0xba>
    1348:	10 92 44 02 	sts	0x0244, r1	; 0x800244 <uxPendedTicks>
    134c:	80 91 43 02 	lds	r24, 0x0243	; 0x800243 <xYieldPending>
    1350:	88 23       	and	r24, r24
    1352:	29 f0       	breq	.+10     	; 0x135e <xTaskResumeAll+0xdc>
    1354:	97 d9       	rcall	.-3282   	; 0x684 <vPortYield>
    1356:	81 e0       	ldi	r24, 0x01	; 1
    1358:	03 c0       	rjmp	.+6      	; 0x1360 <xTaskResumeAll+0xde>
    135a:	80 e0       	ldi	r24, 0x00	; 0
    135c:	01 c0       	rjmp	.+2      	; 0x1360 <xTaskResumeAll+0xde>
    135e:	80 e0       	ldi	r24, 0x00	; 0
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63
    1364:	df 91       	pop	r29
    1366:	cf 91       	pop	r28
    1368:	1f 91       	pop	r17
    136a:	0f 91       	pop	r16
    136c:	ff 90       	pop	r15
    136e:	ef 90       	pop	r14
    1370:	df 90       	pop	r13
    1372:	08 95       	ret

00001374 <vTaskDelay>:
    1374:	cf 93       	push	r28
    1376:	df 93       	push	r29
    1378:	ec 01       	movw	r28, r24
    137a:	89 2b       	or	r24, r25
    137c:	39 f0       	breq	.+14     	; 0x138c <vTaskDelay+0x18>
    137e:	ba de       	rcall	.-652    	; 0x10f4 <vTaskSuspendAll>
    1380:	60 e0       	ldi	r22, 0x00	; 0
    1382:	ce 01       	movw	r24, r28
    1384:	25 dd       	rcall	.-1462   	; 0xdd0 <prvAddCurrentTaskToDelayedList>
    1386:	7d df       	rcall	.-262    	; 0x1282 <xTaskResumeAll>
    1388:	81 11       	cpse	r24, r1
    138a:	01 c0       	rjmp	.+2      	; 0x138e <vTaskDelay+0x1a>
    138c:	7b d9       	rcall	.-3338   	; 0x684 <vPortYield>
    138e:	df 91       	pop	r29
    1390:	cf 91       	pop	r28
    1392:	08 95       	ret

00001394 <vTaskSetApplicationTaskTag>:
    1394:	00 97       	sbiw	r24, 0x00	; 0
    1396:	21 f4       	brne	.+8      	; 0x13a0 <vTaskSetApplicationTaskTag+0xc>
    1398:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    139c:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    13a0:	0f b6       	in	r0, 0x3f	; 63
    13a2:	f8 94       	cli
    13a4:	0f 92       	push	r0
    13a6:	fc 01       	movw	r30, r24
    13a8:	76 a3       	std	Z+38, r23	; 0x26
    13aa:	65 a3       	std	Z+37, r22	; 0x25
    13ac:	0f 90       	pop	r0
    13ae:	0f be       	out	0x3f, r0	; 63
    13b0:	08 95       	ret

000013b2 <vTaskSwitchContext>:
    13b2:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <__data_end>
    13b6:	88 23       	and	r24, r24
    13b8:	21 f0       	breq	.+8      	; 0x13c2 <vTaskSwitchContext+0x10>
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <xYieldPending>
    13c0:	08 95       	ret
    13c2:	10 92 43 02 	sts	0x0243, r1	; 0x800243 <xYieldPending>
    13c6:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    13ca:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    13ce:	85 a1       	ldd	r24, Z+37	; 0x25
    13d0:	0e 94 e5 01 	call	0x3ca	; 0x3ca <task_switch_out>
    13d4:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    13d8:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    13dc:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    13e0:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    13e4:	2d 91       	ld	r18, X+
    13e6:	3c 91       	ld	r19, X
    13e8:	87 89       	ldd	r24, Z+23	; 0x17
    13ea:	90 8d       	ldd	r25, Z+24	; 0x18
    13ec:	82 17       	cp	r24, r18
    13ee:	93 07       	cpc	r25, r19
    13f0:	58 f0       	brcs	.+22     	; 0x1408 <vTaskSwitchContext+0x56>
    13f2:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    13f6:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    13fa:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    13fe:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1402:	67 5e       	subi	r22, 0xE7	; 231
    1404:	7f 4f       	sbci	r23, 0xFF	; 255
    1406:	9d d2       	rcall	.+1338   	; 0x1942 <vApplicationStackOverflowHook>
    1408:	20 91 46 02 	lds	r18, 0x0246	; 0x800246 <uxTopReadyPriority>
    140c:	82 2f       	mov	r24, r18
    140e:	90 e0       	ldi	r25, 0x00	; 0
    1410:	fc 01       	movw	r30, r24
    1412:	ee 0f       	add	r30, r30
    1414:	ff 1f       	adc	r31, r31
    1416:	ee 0f       	add	r30, r30
    1418:	ff 1f       	adc	r31, r31
    141a:	ee 0f       	add	r30, r30
    141c:	ff 1f       	adc	r31, r31
    141e:	e8 0f       	add	r30, r24
    1420:	f9 1f       	adc	r31, r25
    1422:	e4 58       	subi	r30, 0x84	; 132
    1424:	fd 4f       	sbci	r31, 0xFD	; 253
    1426:	30 81       	ld	r19, Z
    1428:	31 11       	cpse	r19, r1
    142a:	11 c0       	rjmp	.+34     	; 0x144e <vTaskSwitchContext+0x9c>
    142c:	21 50       	subi	r18, 0x01	; 1
    142e:	82 2f       	mov	r24, r18
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	fc 01       	movw	r30, r24
    1434:	ee 0f       	add	r30, r30
    1436:	ff 1f       	adc	r31, r31
    1438:	ee 0f       	add	r30, r30
    143a:	ff 1f       	adc	r31, r31
    143c:	ee 0f       	add	r30, r30
    143e:	ff 1f       	adc	r31, r31
    1440:	e8 0f       	add	r30, r24
    1442:	f9 1f       	adc	r31, r25
    1444:	e4 58       	subi	r30, 0x84	; 132
    1446:	fd 4f       	sbci	r31, 0xFD	; 253
    1448:	30 81       	ld	r19, Z
    144a:	33 23       	and	r19, r19
    144c:	79 f3       	breq	.-34     	; 0x142c <vTaskSwitchContext+0x7a>
    144e:	ac 01       	movw	r20, r24
    1450:	44 0f       	add	r20, r20
    1452:	55 1f       	adc	r21, r21
    1454:	44 0f       	add	r20, r20
    1456:	55 1f       	adc	r21, r21
    1458:	44 0f       	add	r20, r20
    145a:	55 1f       	adc	r21, r21
    145c:	48 0f       	add	r20, r24
    145e:	59 1f       	adc	r21, r25
    1460:	da 01       	movw	r26, r20
    1462:	a4 58       	subi	r26, 0x84	; 132
    1464:	bd 4f       	sbci	r27, 0xFD	; 253
    1466:	11 96       	adiw	r26, 0x01	; 1
    1468:	ed 91       	ld	r30, X+
    146a:	fc 91       	ld	r31, X
    146c:	12 97       	sbiw	r26, 0x02	; 2
    146e:	02 80       	ldd	r0, Z+2	; 0x02
    1470:	f3 81       	ldd	r31, Z+3	; 0x03
    1472:	e0 2d       	mov	r30, r0
    1474:	12 96       	adiw	r26, 0x02	; 2
    1476:	fc 93       	st	X, r31
    1478:	ee 93       	st	-X, r30
    147a:	11 97       	sbiw	r26, 0x01	; 1
    147c:	41 58       	subi	r20, 0x81	; 129
    147e:	5d 4f       	sbci	r21, 0xFD	; 253
    1480:	e4 17       	cp	r30, r20
    1482:	f5 07       	cpc	r31, r21
    1484:	29 f4       	brne	.+10     	; 0x1490 <vTaskSwitchContext+0xde>
    1486:	42 81       	ldd	r20, Z+2	; 0x02
    1488:	53 81       	ldd	r21, Z+3	; 0x03
    148a:	fd 01       	movw	r30, r26
    148c:	52 83       	std	Z+2, r21	; 0x02
    148e:	41 83       	std	Z+1, r20	; 0x01
    1490:	fc 01       	movw	r30, r24
    1492:	ee 0f       	add	r30, r30
    1494:	ff 1f       	adc	r31, r31
    1496:	ee 0f       	add	r30, r30
    1498:	ff 1f       	adc	r31, r31
    149a:	ee 0f       	add	r30, r30
    149c:	ff 1f       	adc	r31, r31
    149e:	8e 0f       	add	r24, r30
    14a0:	9f 1f       	adc	r25, r31
    14a2:	fc 01       	movw	r30, r24
    14a4:	e4 58       	subi	r30, 0x84	; 132
    14a6:	fd 4f       	sbci	r31, 0xFD	; 253
    14a8:	01 80       	ldd	r0, Z+1	; 0x01
    14aa:	f2 81       	ldd	r31, Z+2	; 0x02
    14ac:	e0 2d       	mov	r30, r0
    14ae:	86 81       	ldd	r24, Z+6	; 0x06
    14b0:	97 81       	ldd	r25, Z+7	; 0x07
    14b2:	90 93 a1 02 	sts	0x02A1, r25	; 0x8002a1 <pxCurrentTCB+0x1>
    14b6:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <pxCurrentTCB>
    14ba:	20 93 46 02 	sts	0x0246, r18	; 0x800246 <uxTopReadyPriority>
    14be:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    14c2:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    14c6:	85 a1       	ldd	r24, Z+37	; 0x25
    14c8:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <task_switch_in>
    14cc:	08 95       	ret

000014ce <vTaskPlaceOnEventList>:
    14ce:	cf 93       	push	r28
    14d0:	df 93       	push	r29
    14d2:	eb 01       	movw	r28, r22
    14d4:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    14d8:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    14dc:	64 5f       	subi	r22, 0xF4	; 244
    14de:	7f 4f       	sbci	r23, 0xFF	; 255
    14e0:	0e 94 3c 02 	call	0x478	; 0x478 <vListInsert>
    14e4:	61 e0       	ldi	r22, 0x01	; 1
    14e6:	ce 01       	movw	r24, r28
    14e8:	73 dc       	rcall	.-1818   	; 0xdd0 <prvAddCurrentTaskToDelayedList>
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	08 95       	ret

000014f0 <vTaskPlaceOnEventListRestricted>:
    14f0:	0f 93       	push	r16
    14f2:	1f 93       	push	r17
    14f4:	cf 93       	push	r28
    14f6:	8b 01       	movw	r16, r22
    14f8:	c4 2f       	mov	r28, r20
    14fa:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    14fe:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1502:	64 5f       	subi	r22, 0xF4	; 244
    1504:	7f 4f       	sbci	r23, 0xFF	; 255
    1506:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>
    150a:	cc 23       	and	r28, r28
    150c:	11 f0       	breq	.+4      	; 0x1512 <vTaskPlaceOnEventListRestricted+0x22>
    150e:	0f ef       	ldi	r16, 0xFF	; 255
    1510:	1f ef       	ldi	r17, 0xFF	; 255
    1512:	6c 2f       	mov	r22, r28
    1514:	c8 01       	movw	r24, r16
    1516:	5c dc       	rcall	.-1864   	; 0xdd0 <prvAddCurrentTaskToDelayedList>
    1518:	cf 91       	pop	r28
    151a:	1f 91       	pop	r17
    151c:	0f 91       	pop	r16
    151e:	08 95       	ret

00001520 <xTaskRemoveFromEventList>:
    1520:	0f 93       	push	r16
    1522:	1f 93       	push	r17
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	dc 01       	movw	r26, r24
    152a:	15 96       	adiw	r26, 0x05	; 5
    152c:	ed 91       	ld	r30, X+
    152e:	fc 91       	ld	r31, X
    1530:	16 97       	sbiw	r26, 0x06	; 6
    1532:	c6 81       	ldd	r28, Z+6	; 0x06
    1534:	d7 81       	ldd	r29, Z+7	; 0x07
    1536:	8e 01       	movw	r16, r28
    1538:	04 5f       	subi	r16, 0xF4	; 244
    153a:	1f 4f       	sbci	r17, 0xFF	; 255
    153c:	c8 01       	movw	r24, r16
    153e:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
    1542:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <__data_end>
    1546:	81 11       	cpse	r24, r1
    1548:	1c c0       	rjmp	.+56     	; 0x1582 <xTaskRemoveFromEventList+0x62>
    154a:	0a 50       	subi	r16, 0x0A	; 10
    154c:	11 09       	sbc	r17, r1
    154e:	c8 01       	movw	r24, r16
    1550:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
    1554:	8e 89       	ldd	r24, Y+22	; 0x16
    1556:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    155a:	98 17       	cp	r25, r24
    155c:	10 f4       	brcc	.+4      	; 0x1562 <xTaskRemoveFromEventList+0x42>
    155e:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	9c 01       	movw	r18, r24
    1566:	22 0f       	add	r18, r18
    1568:	33 1f       	adc	r19, r19
    156a:	22 0f       	add	r18, r18
    156c:	33 1f       	adc	r19, r19
    156e:	22 0f       	add	r18, r18
    1570:	33 1f       	adc	r19, r19
    1572:	82 0f       	add	r24, r18
    1574:	93 1f       	adc	r25, r19
    1576:	b8 01       	movw	r22, r16
    1578:	84 58       	subi	r24, 0x84	; 132
    157a:	9d 4f       	sbci	r25, 0xFD	; 253
    157c:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>
    1580:	05 c0       	rjmp	.+10     	; 0x158c <xTaskRemoveFromEventList+0x6c>
    1582:	b8 01       	movw	r22, r16
    1584:	8d e5       	ldi	r24, 0x5D	; 93
    1586:	92 e0       	ldi	r25, 0x02	; 2
    1588:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>
    158c:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1590:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1594:	9e 89       	ldd	r25, Y+22	; 0x16
    1596:	86 89       	ldd	r24, Z+22	; 0x16
    1598:	89 17       	cp	r24, r25
    159a:	20 f4       	brcc	.+8      	; 0x15a4 <xTaskRemoveFromEventList+0x84>
    159c:	81 e0       	ldi	r24, 0x01	; 1
    159e:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <xYieldPending>
    15a2:	01 c0       	rjmp	.+2      	; 0x15a6 <xTaskRemoveFromEventList+0x86>
    15a4:	80 e0       	ldi	r24, 0x00	; 0
    15a6:	df 91       	pop	r29
    15a8:	cf 91       	pop	r28
    15aa:	1f 91       	pop	r17
    15ac:	0f 91       	pop	r16
    15ae:	08 95       	ret

000015b0 <vTaskInternalSetTimeOutState>:
    15b0:	20 91 42 02 	lds	r18, 0x0242	; 0x800242 <xNumOfOverflows>
    15b4:	fc 01       	movw	r30, r24
    15b6:	20 83       	st	Z, r18
    15b8:	20 91 47 02 	lds	r18, 0x0247	; 0x800247 <xTickCount>
    15bc:	30 91 48 02 	lds	r19, 0x0248	; 0x800248 <xTickCount+0x1>
    15c0:	32 83       	std	Z+2, r19	; 0x02
    15c2:	21 83       	std	Z+1, r18	; 0x01
    15c4:	08 95       	ret

000015c6 <xTaskCheckForTimeOut>:
    15c6:	cf 93       	push	r28
    15c8:	df 93       	push	r29
    15ca:	0f b6       	in	r0, 0x3f	; 63
    15cc:	f8 94       	cli
    15ce:	0f 92       	push	r0
    15d0:	20 91 47 02 	lds	r18, 0x0247	; 0x800247 <xTickCount>
    15d4:	30 91 48 02 	lds	r19, 0x0248	; 0x800248 <xTickCount+0x1>
    15d8:	db 01       	movw	r26, r22
    15da:	4d 91       	ld	r20, X+
    15dc:	5c 91       	ld	r21, X
    15de:	4f 3f       	cpi	r20, 0xFF	; 255
    15e0:	bf ef       	ldi	r27, 0xFF	; 255
    15e2:	5b 07       	cpc	r21, r27
    15e4:	e9 f0       	breq	.+58     	; 0x1620 <xTaskCheckForTimeOut+0x5a>
    15e6:	ec 01       	movw	r28, r24
    15e8:	e9 81       	ldd	r30, Y+1	; 0x01
    15ea:	fa 81       	ldd	r31, Y+2	; 0x02
    15ec:	a0 91 42 02 	lds	r26, 0x0242	; 0x800242 <xNumOfOverflows>
    15f0:	b8 81       	ld	r27, Y
    15f2:	ba 17       	cp	r27, r26
    15f4:	19 f0       	breq	.+6      	; 0x15fc <xTaskCheckForTimeOut+0x36>
    15f6:	2e 17       	cp	r18, r30
    15f8:	3f 07       	cpc	r19, r31
    15fa:	a0 f4       	brcc	.+40     	; 0x1624 <xTaskCheckForTimeOut+0x5e>
    15fc:	2e 1b       	sub	r18, r30
    15fe:	3f 0b       	sbc	r19, r31
    1600:	24 17       	cp	r18, r20
    1602:	35 07       	cpc	r19, r21
    1604:	40 f4       	brcc	.+16     	; 0x1616 <xTaskCheckForTimeOut+0x50>
    1606:	fb 01       	movw	r30, r22
    1608:	42 1b       	sub	r20, r18
    160a:	53 0b       	sbc	r21, r19
    160c:	51 83       	std	Z+1, r21	; 0x01
    160e:	40 83       	st	Z, r20
    1610:	cf df       	rcall	.-98     	; 0x15b0 <vTaskInternalSetTimeOutState>
    1612:	80 e0       	ldi	r24, 0x00	; 0
    1614:	08 c0       	rjmp	.+16     	; 0x1626 <xTaskCheckForTimeOut+0x60>
    1616:	fb 01       	movw	r30, r22
    1618:	11 82       	std	Z+1, r1	; 0x01
    161a:	10 82       	st	Z, r1
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	03 c0       	rjmp	.+6      	; 0x1626 <xTaskCheckForTimeOut+0x60>
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	01 c0       	rjmp	.+2      	; 0x1626 <xTaskCheckForTimeOut+0x60>
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	0f 90       	pop	r0
    1628:	0f be       	out	0x3f, r0	; 63
    162a:	df 91       	pop	r29
    162c:	cf 91       	pop	r28
    162e:	08 95       	ret

00001630 <vTaskMissedYield>:
    1630:	81 e0       	ldi	r24, 0x01	; 1
    1632:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <xYieldPending>
    1636:	08 95       	ret

00001638 <xTaskGetSchedulerState>:
    1638:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <xSchedulerRunning>
    163c:	88 23       	and	r24, r24
    163e:	31 f0       	breq	.+12     	; 0x164c <xTaskGetSchedulerState+0x14>
    1640:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <__data_end>
    1644:	88 23       	and	r24, r24
    1646:	21 f0       	breq	.+8      	; 0x1650 <xTaskGetSchedulerState+0x18>
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	08 95       	ret
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	08 95       	ret
    1650:	82 e0       	ldi	r24, 0x02	; 2
    1652:	08 95       	ret

00001654 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    165e:	89 2b       	or	r24, r25
    1660:	79 f1       	breq	.+94     	; 0x16c0 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    1662:	84 a1       	ldd	r24, Z+36	; 0x24
    1664:	81 50       	subi	r24, 0x01	; 1
    1666:	84 a3       	std	Z+36, r24	; 0x24

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1668:	26 89       	ldd	r18, Z+22	; 0x16
    166a:	93 a1       	ldd	r25, Z+35	; 0x23
    166c:	29 17       	cp	r18, r25
    166e:	51 f1       	breq	.+84     	; 0x16c4 <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1670:	81 11       	cpse	r24, r1
    1672:	2a c0       	rjmp	.+84     	; 0x16c8 <xTaskPriorityDisinherit+0x74>
    1674:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1676:	8f 01       	movw	r16, r30
    1678:	0e 5f       	subi	r16, 0xFE	; 254
    167a:	1f 4f       	sbci	r17, 0xFF	; 255
    167c:	c8 01       	movw	r24, r16
    167e:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    1682:	8b a1       	ldd	r24, Y+35	; 0x23
    1684:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1686:	24 e0       	ldi	r18, 0x04	; 4
    1688:	30 e0       	ldi	r19, 0x00	; 0
    168a:	28 1b       	sub	r18, r24
    168c:	31 09       	sbc	r19, r1
    168e:	3d 87       	std	Y+13, r19	; 0x0d
    1690:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    1692:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    1696:	98 17       	cp	r25, r24
    1698:	10 f4       	brcc	.+4      	; 0x169e <xTaskPriorityDisinherit+0x4a>
    169a:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    169e:	90 e0       	ldi	r25, 0x00	; 0
    16a0:	9c 01       	movw	r18, r24
    16a2:	22 0f       	add	r18, r18
    16a4:	33 1f       	adc	r19, r19
    16a6:	22 0f       	add	r18, r18
    16a8:	33 1f       	adc	r19, r19
    16aa:	22 0f       	add	r18, r18
    16ac:	33 1f       	adc	r19, r19
    16ae:	82 0f       	add	r24, r18
    16b0:	93 1f       	adc	r25, r19
    16b2:	b8 01       	movw	r22, r16
    16b4:	84 58       	subi	r24, 0x84	; 132
    16b6:	9d 4f       	sbci	r25, 0xFD	; 253
    16b8:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    16bc:	81 e0       	ldi	r24, 0x01	; 1
    16be:	05 c0       	rjmp	.+10     	; 0x16ca <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    16c0:	80 e0       	ldi	r24, 0x00	; 0
    16c2:	03 c0       	rjmp	.+6      	; 0x16ca <xTaskPriorityDisinherit+0x76>
    16c4:	80 e0       	ldi	r24, 0x00	; 0
    16c6:	01 c0       	rjmp	.+2      	; 0x16ca <xTaskPriorityDisinherit+0x76>
    16c8:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    16ca:	df 91       	pop	r29
    16cc:	cf 91       	pop	r28
    16ce:	1f 91       	pop	r17
    16d0:	0f 91       	pop	r16
    16d2:	08 95       	ret

000016d4 <prvInsertTimerInActiveList>:
    16d4:	fc 01       	movw	r30, r24
    16d6:	73 83       	std	Z+3, r23	; 0x03
    16d8:	62 83       	std	Z+2, r22	; 0x02
    16da:	91 87       	std	Z+9, r25	; 0x09
    16dc:	80 87       	std	Z+8, r24	; 0x08
    16de:	46 17       	cp	r20, r22
    16e0:	57 07       	cpc	r21, r23
    16e2:	90 f0       	brcs	.+36     	; 0x1708 <prvInsertTimerInActiveList+0x34>
    16e4:	42 1b       	sub	r20, r18
    16e6:	53 0b       	sbc	r21, r19
    16e8:	84 85       	ldd	r24, Z+12	; 0x0c
    16ea:	95 85       	ldd	r25, Z+13	; 0x0d
    16ec:	48 17       	cp	r20, r24
    16ee:	59 07       	cpc	r21, r25
    16f0:	e0 f4       	brcc	.+56     	; 0x172a <prvInsertTimerInActiveList+0x56>
    16f2:	bf 01       	movw	r22, r30
    16f4:	6e 5f       	subi	r22, 0xFE	; 254
    16f6:	7f 4f       	sbci	r23, 0xFF	; 255
    16f8:	80 91 a8 02 	lds	r24, 0x02A8	; 0x8002a8 <pxOverflowTimerList>
    16fc:	90 91 a9 02 	lds	r25, 0x02A9	; 0x8002a9 <pxOverflowTimerList+0x1>
    1700:	0e 94 3c 02 	call	0x478	; 0x478 <vListInsert>
    1704:	80 e0       	ldi	r24, 0x00	; 0
    1706:	08 95       	ret
    1708:	42 17       	cp	r20, r18
    170a:	53 07       	cpc	r21, r19
    170c:	18 f4       	brcc	.+6      	; 0x1714 <prvInsertTimerInActiveList+0x40>
    170e:	62 17       	cp	r22, r18
    1710:	73 07       	cpc	r23, r19
    1712:	68 f4       	brcc	.+26     	; 0x172e <prvInsertTimerInActiveList+0x5a>
    1714:	bf 01       	movw	r22, r30
    1716:	6e 5f       	subi	r22, 0xFE	; 254
    1718:	7f 4f       	sbci	r23, 0xFF	; 255
    171a:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <pxCurrentTimerList>
    171e:	90 91 ab 02 	lds	r25, 0x02AB	; 0x8002ab <pxCurrentTimerList+0x1>
    1722:	0e 94 3c 02 	call	0x478	; 0x478 <vListInsert>
    1726:	80 e0       	ldi	r24, 0x00	; 0
    1728:	08 95       	ret
    172a:	81 e0       	ldi	r24, 0x01	; 1
    172c:	08 95       	ret
    172e:	81 e0       	ldi	r24, 0x01	; 1
    1730:	08 95       	ret

00001732 <prvCheckForValidListAndQueue>:
    1732:	0f b6       	in	r0, 0x3f	; 63
    1734:	f8 94       	cli
    1736:	0f 92       	push	r0
    1738:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <xTimerQueue>
    173c:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <xTimerQueue+0x1>
    1740:	89 2b       	or	r24, r25
    1742:	e1 f4       	brne	.+56     	; 0x177c <prvCheckForValidListAndQueue+0x4a>
    1744:	85 eb       	ldi	r24, 0xB5	; 181
    1746:	92 e0       	ldi	r25, 0x02	; 2
    1748:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
    174c:	8c ea       	ldi	r24, 0xAC	; 172
    174e:	92 e0       	ldi	r25, 0x02	; 2
    1750:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
    1754:	85 eb       	ldi	r24, 0xB5	; 181
    1756:	92 e0       	ldi	r25, 0x02	; 2
    1758:	90 93 ab 02 	sts	0x02AB, r25	; 0x8002ab <pxCurrentTimerList+0x1>
    175c:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <pxCurrentTimerList>
    1760:	8c ea       	ldi	r24, 0xAC	; 172
    1762:	92 e0       	ldi	r25, 0x02	; 2
    1764:	90 93 a9 02 	sts	0x02A9, r25	; 0x8002a9 <pxOverflowTimerList+0x1>
    1768:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <pxOverflowTimerList>
    176c:	40 e0       	ldi	r20, 0x00	; 0
    176e:	65 e0       	ldi	r22, 0x05	; 5
    1770:	8a e0       	ldi	r24, 0x0A	; 10
    1772:	5b d9       	rcall	.-3402   	; 0xa2a <xQueueGenericCreate>
    1774:	90 93 a7 02 	sts	0x02A7, r25	; 0x8002a7 <xTimerQueue+0x1>
    1778:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <xTimerQueue>
    177c:	0f 90       	pop	r0
    177e:	0f be       	out	0x3f, r0	; 63
    1780:	08 95       	ret

00001782 <xTimerCreateTimerTask>:
    1782:	ef 92       	push	r14
    1784:	ff 92       	push	r15
    1786:	0f 93       	push	r16
    1788:	d4 df       	rcall	.-88     	; 0x1732 <prvCheckForValidListAndQueue>
    178a:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <xTimerQueue>
    178e:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <xTimerQueue+0x1>
    1792:	89 2b       	or	r24, r25
    1794:	89 f0       	breq	.+34     	; 0x17b8 <xTimerCreateTimerTask+0x36>
    1796:	0f 2e       	mov	r0, r31
    1798:	f4 ea       	ldi	r31, 0xA4	; 164
    179a:	ef 2e       	mov	r14, r31
    179c:	f2 e0       	ldi	r31, 0x02	; 2
    179e:	ff 2e       	mov	r15, r31
    17a0:	f0 2d       	mov	r31, r0
    17a2:	03 e0       	ldi	r16, 0x03	; 3
    17a4:	20 e0       	ldi	r18, 0x00	; 0
    17a6:	30 e0       	ldi	r19, 0x00	; 0
    17a8:	45 e5       	ldi	r20, 0x55	; 85
    17aa:	50 e0       	ldi	r21, 0x00	; 0
    17ac:	6b e0       	ldi	r22, 0x0B	; 11
    17ae:	72 e0       	ldi	r23, 0x02	; 2
    17b0:	82 eb       	ldi	r24, 0xB2	; 178
    17b2:	90 e0       	ldi	r25, 0x00	; 0
    17b4:	61 db       	rcall	.-2366   	; 0xe78 <xTaskCreate>
    17b6:	01 c0       	rjmp	.+2      	; 0x17ba <xTimerCreateTimerTask+0x38>
    17b8:	80 e0       	ldi	r24, 0x00	; 0
    17ba:	0f 91       	pop	r16
    17bc:	ff 90       	pop	r15
    17be:	ef 90       	pop	r14
    17c0:	08 95       	ret

000017c2 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    17c2:	0f 93       	push	r16
    17c4:	1f 93       	push	r17
    17c6:	cf 93       	push	r28
    17c8:	df 93       	push	r29
    17ca:	00 d0       	rcall	.+0      	; 0x17cc <xTimerGenericCommand+0xa>
    17cc:	1f 92       	push	r1
    17ce:	1f 92       	push	r1
    17d0:	cd b7       	in	r28, 0x3d	; 61
    17d2:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    17d4:	e0 91 a6 02 	lds	r30, 0x02A6	; 0x8002a6 <xTimerQueue>
    17d8:	f0 91 a7 02 	lds	r31, 0x02A7	; 0x8002a7 <xTimerQueue+0x1>
    17dc:	30 97       	sbiw	r30, 0x00	; 0
    17de:	51 f1       	breq	.+84     	; 0x1834 <xTimerGenericCommand+0x72>
    17e0:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    17e2:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    17e4:	5b 83       	std	Y+3, r21	; 0x03
    17e6:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    17e8:	9d 83       	std	Y+5, r25	; 0x05
    17ea:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    17ec:	66 30       	cpi	r22, 0x06	; 6
    17ee:	d4 f4       	brge	.+52     	; 0x1824 <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    17f0:	23 df       	rcall	.-442    	; 0x1638 <xTaskGetSchedulerState>
    17f2:	82 30       	cpi	r24, 0x02	; 2
    17f4:	59 f4       	brne	.+22     	; 0x180c <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    17f6:	20 e0       	ldi	r18, 0x00	; 0
    17f8:	a8 01       	movw	r20, r16
    17fa:	be 01       	movw	r22, r28
    17fc:	6f 5f       	subi	r22, 0xFF	; 255
    17fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1800:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <xTimerQueue>
    1804:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <xTimerQueue+0x1>
    1808:	3e d9       	rcall	.-3460   	; 0xa86 <xQueueGenericSend>
    180a:	15 c0       	rjmp	.+42     	; 0x1836 <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    180c:	20 e0       	ldi	r18, 0x00	; 0
    180e:	40 e0       	ldi	r20, 0x00	; 0
    1810:	50 e0       	ldi	r21, 0x00	; 0
    1812:	be 01       	movw	r22, r28
    1814:	6f 5f       	subi	r22, 0xFF	; 255
    1816:	7f 4f       	sbci	r23, 0xFF	; 255
    1818:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <xTimerQueue>
    181c:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <xTimerQueue+0x1>
    1820:	32 d9       	rcall	.-3484   	; 0xa86 <xQueueGenericSend>
    1822:	09 c0       	rjmp	.+18     	; 0x1836 <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1824:	20 e0       	ldi	r18, 0x00	; 0
    1826:	ad 01       	movw	r20, r26
    1828:	be 01       	movw	r22, r28
    182a:	6f 5f       	subi	r22, 0xFF	; 255
    182c:	7f 4f       	sbci	r23, 0xFF	; 255
    182e:	cf 01       	movw	r24, r30
    1830:	d4 d9       	rcall	.-3160   	; 0xbda <xQueueGenericSendFromISR>
    1832:	01 c0       	rjmp	.+2      	; 0x1836 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    1834:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    1836:	0f 90       	pop	r0
    1838:	0f 90       	pop	r0
    183a:	0f 90       	pop	r0
    183c:	0f 90       	pop	r0
    183e:	0f 90       	pop	r0
    1840:	df 91       	pop	r29
    1842:	cf 91       	pop	r28
    1844:	1f 91       	pop	r17
    1846:	0f 91       	pop	r16
    1848:	08 95       	ret

0000184a <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    184a:	af 92       	push	r10
    184c:	bf 92       	push	r11
    184e:	cf 92       	push	r12
    1850:	df 92       	push	r13
    1852:	ef 92       	push	r14
    1854:	ff 92       	push	r15
    1856:	0f 93       	push	r16
    1858:	1f 93       	push	r17
    185a:	cf 93       	push	r28
    185c:	df 93       	push	r29
    185e:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    1860:	4f dc       	rcall	.-1890   	; 0x1100 <xTaskGetTickCount>
    1862:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    1864:	80 91 a2 02 	lds	r24, 0x02A2	; 0x8002a2 <xLastTime.2432>
    1868:	90 91 a3 02 	lds	r25, 0x02A3	; 0x8002a3 <xLastTime.2432+0x1>
    186c:	e8 16       	cp	r14, r24
    186e:	f9 06       	cpc	r15, r25
    1870:	08 f0       	brcs	.+2      	; 0x1874 <prvSampleTimeNow+0x2a>
    1872:	47 c0       	rjmp	.+142    	; 0x1902 <prvSampleTimeNow+0xb8>
    1874:	2f c0       	rjmp	.+94     	; 0x18d4 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1876:	05 80       	ldd	r0, Z+5	; 0x05
    1878:	f6 81       	ldd	r31, Z+6	; 0x06
    187a:	e0 2d       	mov	r30, r0
    187c:	a0 80       	ld	r10, Z
    187e:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1880:	c6 81       	ldd	r28, Z+6	; 0x06
    1882:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1884:	8e 01       	movw	r16, r28
    1886:	0e 5f       	subi	r16, 0xFE	; 254
    1888:	1f 4f       	sbci	r17, 0xFF	; 255
    188a:	c8 01       	movw	r24, r16
    188c:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1890:	e8 89       	ldd	r30, Y+16	; 0x10
    1892:	f9 89       	ldd	r31, Y+17	; 0x11
    1894:	ce 01       	movw	r24, r28
    1896:	19 95       	eicall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1898:	8b 89       	ldd	r24, Y+19	; 0x13
    189a:	82 ff       	sbrs	r24, 2
    189c:	1b c0       	rjmp	.+54     	; 0x18d4 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    189e:	8c 85       	ldd	r24, Y+12	; 0x0c
    18a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    18a2:	8a 0d       	add	r24, r10
    18a4:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    18a6:	a8 16       	cp	r10, r24
    18a8:	b9 06       	cpc	r11, r25
    18aa:	60 f4       	brcc	.+24     	; 0x18c4 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    18ac:	9b 83       	std	Y+3, r25	; 0x03
    18ae:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    18b0:	d9 87       	std	Y+9, r29	; 0x09
    18b2:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    18b4:	b8 01       	movw	r22, r16
    18b6:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <pxCurrentTimerList>
    18ba:	90 91 ab 02 	lds	r25, 0x02AB	; 0x8002ab <pxCurrentTimerList+0x1>
    18be:	0e 94 3c 02 	call	0x478	; 0x478 <vListInsert>
    18c2:	08 c0       	rjmp	.+16     	; 0x18d4 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    18c4:	00 e0       	ldi	r16, 0x00	; 0
    18c6:	10 e0       	ldi	r17, 0x00	; 0
    18c8:	20 e0       	ldi	r18, 0x00	; 0
    18ca:	30 e0       	ldi	r19, 0x00	; 0
    18cc:	a5 01       	movw	r20, r10
    18ce:	60 e0       	ldi	r22, 0x00	; 0
    18d0:	ce 01       	movw	r24, r28
    18d2:	77 df       	rcall	.-274    	; 0x17c2 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    18d4:	e0 91 aa 02 	lds	r30, 0x02AA	; 0x8002aa <pxCurrentTimerList>
    18d8:	f0 91 ab 02 	lds	r31, 0x02AB	; 0x8002ab <pxCurrentTimerList+0x1>
    18dc:	80 81       	ld	r24, Z
    18de:	81 11       	cpse	r24, r1
    18e0:	ca cf       	rjmp	.-108    	; 0x1876 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    18e2:	80 91 a8 02 	lds	r24, 0x02A8	; 0x8002a8 <pxOverflowTimerList>
    18e6:	90 91 a9 02 	lds	r25, 0x02A9	; 0x8002a9 <pxOverflowTimerList+0x1>
    18ea:	90 93 ab 02 	sts	0x02AB, r25	; 0x8002ab <pxCurrentTimerList+0x1>
    18ee:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    18f2:	f0 93 a9 02 	sts	0x02A9, r31	; 0x8002a9 <pxOverflowTimerList+0x1>
    18f6:	e0 93 a8 02 	sts	0x02A8, r30	; 0x8002a8 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    18fa:	81 e0       	ldi	r24, 0x01	; 1
    18fc:	f6 01       	movw	r30, r12
    18fe:	80 83       	st	Z, r24
    1900:	02 c0       	rjmp	.+4      	; 0x1906 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    1902:	f6 01       	movw	r30, r12
    1904:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    1906:	f0 92 a3 02 	sts	0x02A3, r15	; 0x8002a3 <xLastTime.2432+0x1>
    190a:	e0 92 a2 02 	sts	0x02A2, r14	; 0x8002a2 <xLastTime.2432>

    return xTimeNow;
}
    190e:	c7 01       	movw	r24, r14
    1910:	df 91       	pop	r29
    1912:	cf 91       	pop	r28
    1914:	1f 91       	pop	r17
    1916:	0f 91       	pop	r16
    1918:	ff 90       	pop	r15
    191a:	ef 90       	pop	r14
    191c:	df 90       	pop	r13
    191e:	cf 90       	pop	r12
    1920:	bf 90       	pop	r11
    1922:	af 90       	pop	r10
    1924:	08 95       	ret

00001926 <vApplicationIdleHook>:
 *
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    1926:	08 95       	ret

00001928 <vApplicationMallocFailedHook>:
void vApplicationMallocFailedHook( void ) __attribute__((weak));

void vApplicationMallocFailedHook( void )
{
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Arduino Mega with 2560
    DDRB  |= _BV(DDB7);
    1928:	27 9a       	sbi	0x04, 7	; 4
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    192a:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    192c:	2f ef       	ldi	r18, 0xFF	; 255
    192e:	80 e7       	ldi	r24, 0x70	; 112
    1930:	92 e0       	ldi	r25, 0x02	; 2
    1932:	21 50       	subi	r18, 0x01	; 1
    1934:	80 40       	sbci	r24, 0x00	; 0
    1936:	90 40       	sbci	r25, 0x00	; 0
    1938:	e1 f7       	brne	.-8      	; 0x1932 <vApplicationMallocFailedHook+0xa>
    193a:	00 c0       	rjmp	.+0      	; 0x193c <vApplicationMallocFailedHook+0x14>
    193c:	00 00       	nop
    for(;;)
    {
        _delay_ms(50);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
    193e:	1f 9a       	sbi	0x03, 7	; 3
    1940:	f5 cf       	rjmp	.-22     	; 0x192c <vApplicationMallocFailedHook+0x4>

00001942 <vApplicationStackOverflowHook>:
void vApplicationStackOverflowHook( TaskHandle_t xTask, portCHAR *pcTaskName ) __attribute__((weak));

void vApplicationStackOverflowHook( TaskHandle_t xTask __attribute__((unused)), portCHAR *pcTaskName __attribute__((unused))  )
{
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
    DDRB  |= _BV(DDB7);
    1942:	27 9a       	sbi	0x04, 7	; 4
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    1944:	2f 9a       	sbi	0x05, 7	; 5
    1946:	2f ef       	ldi	r18, 0xFF	; 255
    1948:	87 ea       	ldi	r24, 0xA7	; 167
    194a:	91 e6       	ldi	r25, 0x61	; 97
    194c:	21 50       	subi	r18, 0x01	; 1
    194e:	80 40       	sbci	r24, 0x00	; 0
    1950:	90 40       	sbci	r25, 0x00	; 0
    1952:	e1 f7       	brne	.-8      	; 0x194c <vApplicationStackOverflowHook+0xa>
    1954:	00 c0       	rjmp	.+0      	; 0x1956 <vApplicationStackOverflowHook+0x14>
    1956:	00 00       	nop
    for(;;)
    {
        _delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    1958:	1f 9a       	sbi	0x03, 7	; 3
    195a:	f5 cf       	rjmp	.-22     	; 0x1946 <vApplicationStackOverflowHook+0x4>

0000195c <main>:
#include "myCO2Sensor.h"


int main(void)
{
	DDRA |= _BV(DDA0) | _BV(DDA7);
    195c:	81 b1       	in	r24, 0x01	; 1
    195e:	81 68       	ori	r24, 0x81	; 129
    1960:	81 b9       	out	0x01, r24	; 1
	trace_init();
    1962:	0e 94 d5 01 	call	0x3aa	; 0x3aa <trace_init>


	createSemaphores();
    1966:	11 d0       	rcall	.+34     	; 0x198a <createSemaphores>
	createTasks();
    1968:	3f d0       	rcall	.+126    	; 0x19e8 <createTasks>
	createQueues();
    196a:	06 d0       	rcall	.+12     	; 0x1978 <createQueues>
	createCO2Drivers();
    196c:	02 d0       	rcall	.+4      	; 0x1972 <createCO2Drivers>
    196e:	91 db       	rcall	.-2270   	; 0x1092 <vTaskStartScheduler>
	
	vTaskStartScheduler(); // initialize and run the freeRTOS scheduler. Execution should never return here.
    1970:	ff cf       	rjmp	.-2      	; 0x1970 <main+0x14>

00001972 <createCO2Drivers>:
#include "myCO2Sensor.h"
#include "myQueue.h"

// init/create co2 drivers
void createCO2Drivers(void){
    1972:	08 95       	ret

00001974 <takeCO2Measurement>:

}

// when u access queue (u are adding value to queue) take semaphore 
// so no other task can manipulate with semaphore
void takeCO2Measurement(void){
    1974:	08 95       	ret

00001976 <sendData>:

void createLoRaDriver(){
	
}

void sendData(){
    1976:	08 95       	ret

00001978 <createQueues>:
// myQueues .c and .h should be done -> u can use xQueueMeasurements (global)

void createQueues(){

    // create a queue containing 3 measurement structs. */
    xQueueMeasurements = xQueueCreate( 3, sizeof( structMeasurement ) );
    1978:	40 e0       	ldi	r20, 0x00	; 0
    197a:	66 e0       	ldi	r22, 0x06	; 6
    197c:	83 e0       	ldi	r24, 0x03	; 3
    197e:	55 d8       	rcall	.-3926   	; 0xa2a <xQueueGenericCreate>
    1980:	90 93 bf 02 	sts	0x02BF, r25	; 0x8002bf <xQueueMeasurements+0x1>
    1984:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <xQueueMeasurements>
    1988:	08 95       	ret

0000198a <createSemaphores>:
// 1. create handle in .h header file
// 2. initialize semaphore -> xSemaphoreCreate ... (documatation)

void createSemaphores(void){
	
	if ( xTestSemaphore == NULL ) { // Check to confirm that the Semaphore has not already been created.
    198a:	80 91 c0 02 	lds	r24, 0x02C0	; 0x8002c0 <xTestSemaphore>
    198e:	90 91 c1 02 	lds	r25, 0x02C1	; 0x8002c1 <xTestSemaphore+0x1>
    1992:	89 2b       	or	r24, r25
    1994:	71 f4       	brne	.+28     	; 0x19b2 <createSemaphores+0x28>
		xTestSemaphore = xSemaphoreCreateMutex();  // Create a mutex semaphore.
    1996:	81 e0       	ldi	r24, 0x01	; 1
    1998:	08 d9       	rcall	.-3568   	; 0xbaa <xQueueCreateMutex>
    199a:	90 93 c1 02 	sts	0x02C1, r25	; 0x8002c1 <xTestSemaphore+0x1>
    199e:	80 93 c0 02 	sts	0x02C0, r24	; 0x8002c0 <xTestSemaphore>
		if ( ( xTestSemaphore ) != NULL ) {
    19a2:	00 97       	sbiw	r24, 0x00	; 0
    19a4:	31 f0       	breq	.+12     	; 0x19b2 <createSemaphores+0x28>
			xSemaphoreGive( ( xTestSemaphore ) );  // Make the mutex available for use, by initially "Giving" the Semaphore.
    19a6:	20 e0       	ldi	r18, 0x00	; 0
    19a8:	40 e0       	ldi	r20, 0x00	; 0
    19aa:	50 e0       	ldi	r21, 0x00	; 0
    19ac:	60 e0       	ldi	r22, 0x00	; 0
    19ae:	70 e0       	ldi	r23, 0x00	; 0
    19b0:	6a c8       	rjmp	.-3884   	; 0xa86 <xQueueGenericSend>
    19b2:	08 95       	ret

000019b4 <taskMeassureCO2>:
/*-----------------------------------------------------------*/
void taskMeassureCO2( void *pvParameters )
{
	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 1 );
    19b4:	61 e0       	ldi	r22, 0x01	; 1
    19b6:	70 e0       	ldi	r23, 0x00	; 0
    19b8:	80 e0       	ldi	r24, 0x00	; 0
    19ba:	90 e0       	ldi	r25, 0x00	; 0
    19bc:	eb dc       	rcall	.-1578   	; 0x1394 <vTaskSetApplicationTaskTag>

	
	for(;;)
	{
		// test printout
		puts("task1");
    19be:	83 e1       	ldi	r24, 0x13	; 19
    19c0:	92 e0       	ldi	r25, 0x02	; 2
		
		// if semaphore is free then
		takeCO2Measurement();
    19c2:	67 d1       	rcall	.+718    	; 0x1c92 <puts>
		
		
		vTaskDelay(50);
    19c4:	d7 df       	rcall	.-82     	; 0x1974 <takeCO2Measurement>
    19c6:	82 e3       	ldi	r24, 0x32	; 50
    19c8:	90 e0       	ldi	r25, 0x00	; 0
    19ca:	d4 dc       	rcall	.-1624   	; 0x1374 <vTaskDelay>
    19cc:	f8 cf       	rjmp	.-16     	; 0x19be <taskMeassureCO2+0xa>

000019ce <taskSendData>:
/*-----------------------------------------------------------*/
void taskSendData( void *pvParameters )
{
	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 2 );
    19ce:	62 e0       	ldi	r22, 0x02	; 2
    19d0:	70 e0       	ldi	r23, 0x00	; 0
    19d2:	80 e0       	ldi	r24, 0x00	; 0
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	de dc       	rcall	.-1604   	; 0x1394 <vTaskSetApplicationTaskTag>
	#endif
	
	for(;;)
	{
		// test printout
		puts("task2");
    19d8:	89 e1       	ldi	r24, 0x19	; 25
    19da:	92 e0       	ldi	r25, 0x02	; 2
		
		// if queue has struct with measureme aka if queue has > 0 elements in
		// then send data
		sendData();
    19dc:	5a d1       	rcall	.+692    	; 0x1c92 <puts>
		
		vTaskDelay(50);
    19de:	cb df       	rcall	.-106    	; 0x1976 <sendData>
    19e0:	82 e3       	ldi	r24, 0x32	; 50
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	c7 dc       	rcall	.-1650   	; 0x1374 <vTaskDelay>
    19e6:	f8 cf       	rjmp	.-16     	; 0x19d8 <taskSendData+0xa>

000019e8 <createTasks>:
 */ 
#include "myTasks.h"
#include "myCO2Sensor.h"
#include "myLoRa.h"

void createTasks(void) {
    19e8:	ef 92       	push	r14
    19ea:	ff 92       	push	r15
    19ec:	0f 93       	push	r16
	xTaskCreate(
    19ee:	e1 2c       	mov	r14, r1
    19f0:	f1 2c       	mov	r15, r1
    19f2:	02 e0       	ldi	r16, 0x02	; 2
    19f4:	20 e0       	ldi	r18, 0x00	; 0
    19f6:	30 e0       	ldi	r19, 0x00	; 0
    19f8:	40 ec       	ldi	r20, 0xC0	; 192
    19fa:	50 e0       	ldi	r21, 0x00	; 0
    19fc:	6f e1       	ldi	r22, 0x1F	; 31
    19fe:	72 e0       	ldi	r23, 0x02	; 2
    1a00:	8a ed       	ldi	r24, 0xDA	; 218
    1a02:	9c e0       	ldi	r25, 0x0C	; 12
    1a04:	39 da       	rcall	.-2958   	; 0xe78 <xTaskCreate>
	,  configMINIMAL_STACK_SIZE
	,  NULL
	,  2
	,  NULL );

	xTaskCreate(
    1a06:	20 e0       	ldi	r18, 0x00	; 0
    1a08:	30 e0       	ldi	r19, 0x00	; 0
    1a0a:	40 ec       	ldi	r20, 0xC0	; 192
    1a0c:	50 e0       	ldi	r21, 0x00	; 0
    1a0e:	6f e2       	ldi	r22, 0x2F	; 47
    1a10:	72 e0       	ldi	r23, 0x02	; 2
    1a12:	87 ee       	ldi	r24, 0xE7	; 231
    1a14:	9c e0       	ldi	r25, 0x0C	; 12
    1a16:	30 da       	rcall	.-2976   	; 0xe78 <xTaskCreate>
	,  (const portCHAR *)"TaskSendData"
	,  configMINIMAL_STACK_SIZE
	,  NULL
	,  2
	,  NULL );
}
    1a18:	0f 91       	pop	r16
    1a1a:	ff 90       	pop	r15
    1a1c:	ef 90       	pop	r14
    1a1e:	08 95       	ret

00001a20 <__tablejump2__>:
    1a20:	ee 0f       	add	r30, r30
    1a22:	ff 1f       	adc	r31, r31
    1a24:	88 1f       	adc	r24, r24
    1a26:	8b bf       	out	0x3b, r24	; 59
    1a28:	07 90       	elpm	r0, Z+
    1a2a:	f6 91       	elpm	r31, Z
    1a2c:	e0 2d       	mov	r30, r0
    1a2e:	19 94       	eijmp

00001a30 <malloc>:
    1a30:	0f 93       	push	r16
    1a32:	1f 93       	push	r17
    1a34:	cf 93       	push	r28
    1a36:	df 93       	push	r29
    1a38:	82 30       	cpi	r24, 0x02	; 2
    1a3a:	91 05       	cpc	r25, r1
    1a3c:	10 f4       	brcc	.+4      	; 0x1a42 <malloc+0x12>
    1a3e:	82 e0       	ldi	r24, 0x02	; 2
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	e0 91 c4 02 	lds	r30, 0x02C4	; 0x8002c4 <__flp>
    1a46:	f0 91 c5 02 	lds	r31, 0x02C5	; 0x8002c5 <__flp+0x1>
    1a4a:	20 e0       	ldi	r18, 0x00	; 0
    1a4c:	30 e0       	ldi	r19, 0x00	; 0
    1a4e:	a0 e0       	ldi	r26, 0x00	; 0
    1a50:	b0 e0       	ldi	r27, 0x00	; 0
    1a52:	30 97       	sbiw	r30, 0x00	; 0
    1a54:	19 f1       	breq	.+70     	; 0x1a9c <malloc+0x6c>
    1a56:	40 81       	ld	r20, Z
    1a58:	51 81       	ldd	r21, Z+1	; 0x01
    1a5a:	02 81       	ldd	r16, Z+2	; 0x02
    1a5c:	13 81       	ldd	r17, Z+3	; 0x03
    1a5e:	48 17       	cp	r20, r24
    1a60:	59 07       	cpc	r21, r25
    1a62:	c8 f0       	brcs	.+50     	; 0x1a96 <malloc+0x66>
    1a64:	84 17       	cp	r24, r20
    1a66:	95 07       	cpc	r25, r21
    1a68:	69 f4       	brne	.+26     	; 0x1a84 <malloc+0x54>
    1a6a:	10 97       	sbiw	r26, 0x00	; 0
    1a6c:	31 f0       	breq	.+12     	; 0x1a7a <malloc+0x4a>
    1a6e:	12 96       	adiw	r26, 0x02	; 2
    1a70:	0c 93       	st	X, r16
    1a72:	12 97       	sbiw	r26, 0x02	; 2
    1a74:	13 96       	adiw	r26, 0x03	; 3
    1a76:	1c 93       	st	X, r17
    1a78:	27 c0       	rjmp	.+78     	; 0x1ac8 <malloc+0x98>
    1a7a:	00 93 c4 02 	sts	0x02C4, r16	; 0x8002c4 <__flp>
    1a7e:	10 93 c5 02 	sts	0x02C5, r17	; 0x8002c5 <__flp+0x1>
    1a82:	22 c0       	rjmp	.+68     	; 0x1ac8 <malloc+0x98>
    1a84:	21 15       	cp	r18, r1
    1a86:	31 05       	cpc	r19, r1
    1a88:	19 f0       	breq	.+6      	; 0x1a90 <malloc+0x60>
    1a8a:	42 17       	cp	r20, r18
    1a8c:	53 07       	cpc	r21, r19
    1a8e:	18 f4       	brcc	.+6      	; 0x1a96 <malloc+0x66>
    1a90:	9a 01       	movw	r18, r20
    1a92:	bd 01       	movw	r22, r26
    1a94:	ef 01       	movw	r28, r30
    1a96:	df 01       	movw	r26, r30
    1a98:	f8 01       	movw	r30, r16
    1a9a:	db cf       	rjmp	.-74     	; 0x1a52 <malloc+0x22>
    1a9c:	21 15       	cp	r18, r1
    1a9e:	31 05       	cpc	r19, r1
    1aa0:	f9 f0       	breq	.+62     	; 0x1ae0 <malloc+0xb0>
    1aa2:	28 1b       	sub	r18, r24
    1aa4:	39 0b       	sbc	r19, r25
    1aa6:	24 30       	cpi	r18, 0x04	; 4
    1aa8:	31 05       	cpc	r19, r1
    1aaa:	80 f4       	brcc	.+32     	; 0x1acc <malloc+0x9c>
    1aac:	8a 81       	ldd	r24, Y+2	; 0x02
    1aae:	9b 81       	ldd	r25, Y+3	; 0x03
    1ab0:	61 15       	cp	r22, r1
    1ab2:	71 05       	cpc	r23, r1
    1ab4:	21 f0       	breq	.+8      	; 0x1abe <malloc+0x8e>
    1ab6:	fb 01       	movw	r30, r22
    1ab8:	93 83       	std	Z+3, r25	; 0x03
    1aba:	82 83       	std	Z+2, r24	; 0x02
    1abc:	04 c0       	rjmp	.+8      	; 0x1ac6 <malloc+0x96>
    1abe:	90 93 c5 02 	sts	0x02C5, r25	; 0x8002c5 <__flp+0x1>
    1ac2:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <__flp>
    1ac6:	fe 01       	movw	r30, r28
    1ac8:	32 96       	adiw	r30, 0x02	; 2
    1aca:	44 c0       	rjmp	.+136    	; 0x1b54 <malloc+0x124>
    1acc:	fe 01       	movw	r30, r28
    1ace:	e2 0f       	add	r30, r18
    1ad0:	f3 1f       	adc	r31, r19
    1ad2:	81 93       	st	Z+, r24
    1ad4:	91 93       	st	Z+, r25
    1ad6:	22 50       	subi	r18, 0x02	; 2
    1ad8:	31 09       	sbc	r19, r1
    1ada:	39 83       	std	Y+1, r19	; 0x01
    1adc:	28 83       	st	Y, r18
    1ade:	3a c0       	rjmp	.+116    	; 0x1b54 <malloc+0x124>
    1ae0:	20 91 c2 02 	lds	r18, 0x02C2	; 0x8002c2 <__brkval>
    1ae4:	30 91 c3 02 	lds	r19, 0x02C3	; 0x8002c3 <__brkval+0x1>
    1ae8:	23 2b       	or	r18, r19
    1aea:	41 f4       	brne	.+16     	; 0x1afc <malloc+0xcc>
    1aec:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    1af0:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    1af4:	30 93 c3 02 	sts	0x02C3, r19	; 0x8002c3 <__brkval+0x1>
    1af8:	20 93 c2 02 	sts	0x02C2, r18	; 0x8002c2 <__brkval>
    1afc:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    1b00:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    1b04:	21 15       	cp	r18, r1
    1b06:	31 05       	cpc	r19, r1
    1b08:	41 f4       	brne	.+16     	; 0x1b1a <malloc+0xea>
    1b0a:	2d b7       	in	r18, 0x3d	; 61
    1b0c:	3e b7       	in	r19, 0x3e	; 62
    1b0e:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    1b12:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    1b16:	24 1b       	sub	r18, r20
    1b18:	35 0b       	sbc	r19, r21
    1b1a:	e0 91 c2 02 	lds	r30, 0x02C2	; 0x8002c2 <__brkval>
    1b1e:	f0 91 c3 02 	lds	r31, 0x02C3	; 0x8002c3 <__brkval+0x1>
    1b22:	e2 17       	cp	r30, r18
    1b24:	f3 07       	cpc	r31, r19
    1b26:	a0 f4       	brcc	.+40     	; 0x1b50 <malloc+0x120>
    1b28:	2e 1b       	sub	r18, r30
    1b2a:	3f 0b       	sbc	r19, r31
    1b2c:	28 17       	cp	r18, r24
    1b2e:	39 07       	cpc	r19, r25
    1b30:	78 f0       	brcs	.+30     	; 0x1b50 <malloc+0x120>
    1b32:	ac 01       	movw	r20, r24
    1b34:	4e 5f       	subi	r20, 0xFE	; 254
    1b36:	5f 4f       	sbci	r21, 0xFF	; 255
    1b38:	24 17       	cp	r18, r20
    1b3a:	35 07       	cpc	r19, r21
    1b3c:	48 f0       	brcs	.+18     	; 0x1b50 <malloc+0x120>
    1b3e:	4e 0f       	add	r20, r30
    1b40:	5f 1f       	adc	r21, r31
    1b42:	50 93 c3 02 	sts	0x02C3, r21	; 0x8002c3 <__brkval+0x1>
    1b46:	40 93 c2 02 	sts	0x02C2, r20	; 0x8002c2 <__brkval>
    1b4a:	81 93       	st	Z+, r24
    1b4c:	91 93       	st	Z+, r25
    1b4e:	02 c0       	rjmp	.+4      	; 0x1b54 <malloc+0x124>
    1b50:	e0 e0       	ldi	r30, 0x00	; 0
    1b52:	f0 e0       	ldi	r31, 0x00	; 0
    1b54:	cf 01       	movw	r24, r30
    1b56:	df 91       	pop	r29
    1b58:	cf 91       	pop	r28
    1b5a:	1f 91       	pop	r17
    1b5c:	0f 91       	pop	r16
    1b5e:	08 95       	ret

00001b60 <free>:
    1b60:	cf 93       	push	r28
    1b62:	df 93       	push	r29
    1b64:	00 97       	sbiw	r24, 0x00	; 0
    1b66:	09 f4       	brne	.+2      	; 0x1b6a <free+0xa>
    1b68:	81 c0       	rjmp	.+258    	; 0x1c6c <free+0x10c>
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	32 97       	sbiw	r30, 0x02	; 2
    1b6e:	13 82       	std	Z+3, r1	; 0x03
    1b70:	12 82       	std	Z+2, r1	; 0x02
    1b72:	a0 91 c4 02 	lds	r26, 0x02C4	; 0x8002c4 <__flp>
    1b76:	b0 91 c5 02 	lds	r27, 0x02C5	; 0x8002c5 <__flp+0x1>
    1b7a:	10 97       	sbiw	r26, 0x00	; 0
    1b7c:	81 f4       	brne	.+32     	; 0x1b9e <free+0x3e>
    1b7e:	20 81       	ld	r18, Z
    1b80:	31 81       	ldd	r19, Z+1	; 0x01
    1b82:	82 0f       	add	r24, r18
    1b84:	93 1f       	adc	r25, r19
    1b86:	20 91 c2 02 	lds	r18, 0x02C2	; 0x8002c2 <__brkval>
    1b8a:	30 91 c3 02 	lds	r19, 0x02C3	; 0x8002c3 <__brkval+0x1>
    1b8e:	28 17       	cp	r18, r24
    1b90:	39 07       	cpc	r19, r25
    1b92:	51 f5       	brne	.+84     	; 0x1be8 <free+0x88>
    1b94:	f0 93 c3 02 	sts	0x02C3, r31	; 0x8002c3 <__brkval+0x1>
    1b98:	e0 93 c2 02 	sts	0x02C2, r30	; 0x8002c2 <__brkval>
    1b9c:	67 c0       	rjmp	.+206    	; 0x1c6c <free+0x10c>
    1b9e:	ed 01       	movw	r28, r26
    1ba0:	20 e0       	ldi	r18, 0x00	; 0
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	ce 17       	cp	r28, r30
    1ba6:	df 07       	cpc	r29, r31
    1ba8:	40 f4       	brcc	.+16     	; 0x1bba <free+0x5a>
    1baa:	4a 81       	ldd	r20, Y+2	; 0x02
    1bac:	5b 81       	ldd	r21, Y+3	; 0x03
    1bae:	9e 01       	movw	r18, r28
    1bb0:	41 15       	cp	r20, r1
    1bb2:	51 05       	cpc	r21, r1
    1bb4:	f1 f0       	breq	.+60     	; 0x1bf2 <free+0x92>
    1bb6:	ea 01       	movw	r28, r20
    1bb8:	f5 cf       	rjmp	.-22     	; 0x1ba4 <free+0x44>
    1bba:	d3 83       	std	Z+3, r29	; 0x03
    1bbc:	c2 83       	std	Z+2, r28	; 0x02
    1bbe:	40 81       	ld	r20, Z
    1bc0:	51 81       	ldd	r21, Z+1	; 0x01
    1bc2:	84 0f       	add	r24, r20
    1bc4:	95 1f       	adc	r25, r21
    1bc6:	c8 17       	cp	r28, r24
    1bc8:	d9 07       	cpc	r29, r25
    1bca:	59 f4       	brne	.+22     	; 0x1be2 <free+0x82>
    1bcc:	88 81       	ld	r24, Y
    1bce:	99 81       	ldd	r25, Y+1	; 0x01
    1bd0:	84 0f       	add	r24, r20
    1bd2:	95 1f       	adc	r25, r21
    1bd4:	02 96       	adiw	r24, 0x02	; 2
    1bd6:	91 83       	std	Z+1, r25	; 0x01
    1bd8:	80 83       	st	Z, r24
    1bda:	8a 81       	ldd	r24, Y+2	; 0x02
    1bdc:	9b 81       	ldd	r25, Y+3	; 0x03
    1bde:	93 83       	std	Z+3, r25	; 0x03
    1be0:	82 83       	std	Z+2, r24	; 0x02
    1be2:	21 15       	cp	r18, r1
    1be4:	31 05       	cpc	r19, r1
    1be6:	29 f4       	brne	.+10     	; 0x1bf2 <free+0x92>
    1be8:	f0 93 c5 02 	sts	0x02C5, r31	; 0x8002c5 <__flp+0x1>
    1bec:	e0 93 c4 02 	sts	0x02C4, r30	; 0x8002c4 <__flp>
    1bf0:	3d c0       	rjmp	.+122    	; 0x1c6c <free+0x10c>
    1bf2:	e9 01       	movw	r28, r18
    1bf4:	fb 83       	std	Y+3, r31	; 0x03
    1bf6:	ea 83       	std	Y+2, r30	; 0x02
    1bf8:	49 91       	ld	r20, Y+
    1bfa:	59 91       	ld	r21, Y+
    1bfc:	c4 0f       	add	r28, r20
    1bfe:	d5 1f       	adc	r29, r21
    1c00:	ec 17       	cp	r30, r28
    1c02:	fd 07       	cpc	r31, r29
    1c04:	61 f4       	brne	.+24     	; 0x1c1e <free+0xbe>
    1c06:	80 81       	ld	r24, Z
    1c08:	91 81       	ldd	r25, Z+1	; 0x01
    1c0a:	84 0f       	add	r24, r20
    1c0c:	95 1f       	adc	r25, r21
    1c0e:	02 96       	adiw	r24, 0x02	; 2
    1c10:	e9 01       	movw	r28, r18
    1c12:	99 83       	std	Y+1, r25	; 0x01
    1c14:	88 83       	st	Y, r24
    1c16:	82 81       	ldd	r24, Z+2	; 0x02
    1c18:	93 81       	ldd	r25, Z+3	; 0x03
    1c1a:	9b 83       	std	Y+3, r25	; 0x03
    1c1c:	8a 83       	std	Y+2, r24	; 0x02
    1c1e:	e0 e0       	ldi	r30, 0x00	; 0
    1c20:	f0 e0       	ldi	r31, 0x00	; 0
    1c22:	12 96       	adiw	r26, 0x02	; 2
    1c24:	8d 91       	ld	r24, X+
    1c26:	9c 91       	ld	r25, X
    1c28:	13 97       	sbiw	r26, 0x03	; 3
    1c2a:	00 97       	sbiw	r24, 0x00	; 0
    1c2c:	19 f0       	breq	.+6      	; 0x1c34 <free+0xd4>
    1c2e:	fd 01       	movw	r30, r26
    1c30:	dc 01       	movw	r26, r24
    1c32:	f7 cf       	rjmp	.-18     	; 0x1c22 <free+0xc2>
    1c34:	8d 91       	ld	r24, X+
    1c36:	9c 91       	ld	r25, X
    1c38:	11 97       	sbiw	r26, 0x01	; 1
    1c3a:	9d 01       	movw	r18, r26
    1c3c:	2e 5f       	subi	r18, 0xFE	; 254
    1c3e:	3f 4f       	sbci	r19, 0xFF	; 255
    1c40:	82 0f       	add	r24, r18
    1c42:	93 1f       	adc	r25, r19
    1c44:	20 91 c2 02 	lds	r18, 0x02C2	; 0x8002c2 <__brkval>
    1c48:	30 91 c3 02 	lds	r19, 0x02C3	; 0x8002c3 <__brkval+0x1>
    1c4c:	28 17       	cp	r18, r24
    1c4e:	39 07       	cpc	r19, r25
    1c50:	69 f4       	brne	.+26     	; 0x1c6c <free+0x10c>
    1c52:	30 97       	sbiw	r30, 0x00	; 0
    1c54:	29 f4       	brne	.+10     	; 0x1c60 <free+0x100>
    1c56:	10 92 c5 02 	sts	0x02C5, r1	; 0x8002c5 <__flp+0x1>
    1c5a:	10 92 c4 02 	sts	0x02C4, r1	; 0x8002c4 <__flp>
    1c5e:	02 c0       	rjmp	.+4      	; 0x1c64 <free+0x104>
    1c60:	13 82       	std	Z+3, r1	; 0x03
    1c62:	12 82       	std	Z+2, r1	; 0x02
    1c64:	b0 93 c3 02 	sts	0x02C3, r27	; 0x8002c3 <__brkval+0x1>
    1c68:	a0 93 c2 02 	sts	0x02C2, r26	; 0x8002c2 <__brkval>
    1c6c:	df 91       	pop	r29
    1c6e:	cf 91       	pop	r28
    1c70:	08 95       	ret

00001c72 <memcpy>:
    1c72:	fb 01       	movw	r30, r22
    1c74:	dc 01       	movw	r26, r24
    1c76:	02 c0       	rjmp	.+4      	; 0x1c7c <memcpy+0xa>
    1c78:	01 90       	ld	r0, Z+
    1c7a:	0d 92       	st	X+, r0
    1c7c:	41 50       	subi	r20, 0x01	; 1
    1c7e:	50 40       	sbci	r21, 0x00	; 0
    1c80:	d8 f7       	brcc	.-10     	; 0x1c78 <memcpy+0x6>
    1c82:	08 95       	ret

00001c84 <memset>:
    1c84:	dc 01       	movw	r26, r24
    1c86:	01 c0       	rjmp	.+2      	; 0x1c8a <memset+0x6>
    1c88:	6d 93       	st	X+, r22
    1c8a:	41 50       	subi	r20, 0x01	; 1
    1c8c:	50 40       	sbci	r21, 0x00	; 0
    1c8e:	e0 f7       	brcc	.-8      	; 0x1c88 <memset+0x4>
    1c90:	08 95       	ret

00001c92 <puts>:
    1c92:	0f 93       	push	r16
    1c94:	1f 93       	push	r17
    1c96:	cf 93       	push	r28
    1c98:	df 93       	push	r29
    1c9a:	e0 91 c8 02 	lds	r30, 0x02C8	; 0x8002c8 <__iob+0x2>
    1c9e:	f0 91 c9 02 	lds	r31, 0x02C9	; 0x8002c9 <__iob+0x3>
    1ca2:	23 81       	ldd	r18, Z+3	; 0x03
    1ca4:	21 ff       	sbrs	r18, 1
    1ca6:	1b c0       	rjmp	.+54     	; 0x1cde <puts+0x4c>
    1ca8:	8c 01       	movw	r16, r24
    1caa:	d0 e0       	ldi	r29, 0x00	; 0
    1cac:	c0 e0       	ldi	r28, 0x00	; 0
    1cae:	f8 01       	movw	r30, r16
    1cb0:	81 91       	ld	r24, Z+
    1cb2:	8f 01       	movw	r16, r30
    1cb4:	60 91 c8 02 	lds	r22, 0x02C8	; 0x8002c8 <__iob+0x2>
    1cb8:	70 91 c9 02 	lds	r23, 0x02C9	; 0x8002c9 <__iob+0x3>
    1cbc:	db 01       	movw	r26, r22
    1cbe:	18 96       	adiw	r26, 0x08	; 8
    1cc0:	ed 91       	ld	r30, X+
    1cc2:	fc 91       	ld	r31, X
    1cc4:	19 97       	sbiw	r26, 0x09	; 9
    1cc6:	88 23       	and	r24, r24
    1cc8:	31 f0       	breq	.+12     	; 0x1cd6 <puts+0x44>
    1cca:	19 95       	eicall
    1ccc:	89 2b       	or	r24, r25
    1cce:	79 f3       	breq	.-34     	; 0x1cae <puts+0x1c>
    1cd0:	df ef       	ldi	r29, 0xFF	; 255
    1cd2:	cf ef       	ldi	r28, 0xFF	; 255
    1cd4:	ec cf       	rjmp	.-40     	; 0x1cae <puts+0x1c>
    1cd6:	8a e0       	ldi	r24, 0x0A	; 10
    1cd8:	19 95       	eicall
    1cda:	89 2b       	or	r24, r25
    1cdc:	19 f0       	breq	.+6      	; 0x1ce4 <puts+0x52>
    1cde:	8f ef       	ldi	r24, 0xFF	; 255
    1ce0:	9f ef       	ldi	r25, 0xFF	; 255
    1ce2:	02 c0       	rjmp	.+4      	; 0x1ce8 <puts+0x56>
    1ce4:	8d 2f       	mov	r24, r29
    1ce6:	9c 2f       	mov	r25, r28
    1ce8:	df 91       	pop	r29
    1cea:	cf 91       	pop	r28
    1cec:	1f 91       	pop	r17
    1cee:	0f 91       	pop	r16
    1cf0:	08 95       	ret

00001cf2 <_exit>:
    1cf2:	f8 94       	cli

00001cf4 <__stop_program>:
    1cf4:	ff cf       	rjmp	.-2      	; 0x1cf4 <__stop_program>
